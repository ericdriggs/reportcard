buildscript {
    ext {
        javaVersion = JavaVersion.VERSION_11
    }
}

plugins {
    id 'java'
    id 'idea'
}

sourceCompatibility = javaVersion
targetCompatibility = javaVersion

allprojects {
    apply plugin: 'jacoco'
    group 'io.github.ericdriggs'
    version '0.0.1-SNAPSHOT'

    repositories {
        mavenLocal()
        mavenCentral()
        jcenter()
    }

    tasks.withType(Test) {
        systemProperties = System.properties
        systemProperties['user.dir'] = workingDir
        useJUnitPlatform()
    }

    jacocoTestReport {
        executionData { tasks.withType(Test).findAll { it.jacoco.destinationFile.exists() }*.jacoco.destinationFile }
        reports {
            html.enabled = true
            xml.enabled = true
            csv.enabled = false
        }

        doFirst {
            try {
                classDirectories.from = files(classDirectories.files.collect {
                    fileTree(dir: it, exclude: [
                            'com/github/ericdriggs/reportcard/gen/**',
                            'com/github/ericdriggs/reportcard/gen/db/**',
                            'com/github/ericdriggs/reportcard/gen/db/tables/**',
                            'com/github/ericdriggs/reportcard/gen/db/tables/records/**'
                    ])
                })
            } catch (e) {
                println "jacoco: no exclusion patterns due to ${e.message}"
            }
        }
//        afterEvaluate {
//            classDirectories.from = files(classDirectories.files.collect {
//                fileTree(dir: it, exclude: [
//                        'com/github/ericdriggs/reportcard/gen/**',
//                        'com/github/ericdriggs/reportcard/gen/db/**',
//                        'com/github/ericdriggs/reportcard/gen/db/tables/**',
//                        'com/github/ericdriggs/reportcard/gen/db/tables/records/**'
//                ])
//            })
//        }
    }

}

tasks.register("codeCoverageReport", JacocoReport) {
    // If a subproject applies the 'jacoco' plugin, add the result it to the report
    subprojects { subproject ->
        subproject.plugins.withType(JacocoPlugin).configureEach {
            subproject.tasks.matching({ t -> t.extensions.findByType(JacocoTaskExtension) }).configureEach { testTask ->
                sourceSets subproject.sourceSets.main
                executionData(testTask)
            }

            // To automatically run `test` every time `./gradlew codeCoverageReport` is called,
            // you may want to set up a task dependency between them as shown below.
            // Note that this requires the `test` tasks to be resolved eagerly (see `forEach`) which
            // may have a negative effect on the configuration time of your build.
            subproject.tasks.matching({ t -> t.extensions.findByType(JacocoTaskExtension) }).forEach {
                rootProject.tasks.codeCoverageReport.dependsOn(it)
            }

            doFirst {
                try {
                    classDirectories.from = files(classDirectories.files.collect {
                        fileTree(dir: it, exclude: [
                                'com/github/ericdriggs/reportcard/gen/**',
                                'com/github/ericdriggs/reportcard/gen/db/**',
                                'com/github/ericdriggs/reportcard/gen/db/tables/**',
                                'com/github/ericdriggs/reportcard/gen/db/tables/records/**'
                        ])
                    })
                } catch (e) {
                    println "jacoco: no exclusion patterns due to ${e.message}"
                }
            }
        }
    }

    // enable the different report types (html, xml, csv)
    reports {
        // xml is usually used to integrate code coverage with
        // other tools like SonarQube, Coveralls or Codecov
        xml.enabled true

        // HTML reports can be used to see code coverage
        // without any external tools
        html.enabled true


    }
}
