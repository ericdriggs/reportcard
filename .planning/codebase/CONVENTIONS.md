# Coding Conventions

**Analysis Date:** 2026-01-26

## Naming Patterns

**Files:**
- Classes: PascalCase (e.g., `StageDetails.java`, `TestResultPersistService.java`)
- Interfaces: PascalCase with suffix pattern (e.g., `HasId.java`, `HasNameId.java`)
- Test classes: ClassNameTest (e.g., `StageDetailsTest.java`, `JunitControllerTest.java`)
- DTOs: Suffix with DTO or Response (e.g., `StagePathTestResultResponse.java`, `CompanyOrgRepoDTO.java`)

**Functions/Methods:**
- camelCase for method names (e.g., `postJunitXml()`, `getStageDetails()`, `doPostXml()`)
- Getter/setter style: `get*`, `set*` (generated by Lombok `@Data`, `@Builder`)
- Service methods: verb-first pattern (e.g., `insertTestResult()`, `getTestResult()`, `updateLastRunToNow()`)
- Helper methods: utility-focused names (e.g., `fileToString()`, `getOrInsertStage()`, `upsertedStagePath()`)

**Variables:**
- camelCase for local variables (e.g., `stageDetails`, `testResult`, `xmlString`)
- UPPER_SNAKE_CASE for constants (e.g., `storageKeyPath = "/v1/api/storage/key"`)
- Collections follow standard Java convention (e.g., `testSuites`, `companyGraphs`, `recordResult`)

**Types/Enums:**
- Record-style POJOs: `*Pojo` suffix (generated by JOOQ, e.g., `StoragePojo`)
- Model classes: domain-focused names (e.g., `TestResultModel`, `TestSuiteModel`, `TestCaseModel`)
- Service classes: `*Service` suffix (e.g., `TestResultPersistService`, `StoragePersistService`)
- Helper classes: `*Helper` suffix (e.g., `BadgeHtmlHelper`, `TrendHtmlHelper`)
- Comparator classes: `*Comparator` suffix (e.g., `GraphComparators`, `CommonPrefixComparator`)

## Code Style

**Formatting:**
- Lombok used throughout for boilerplate reduction
- Spring Boot conventions followed
- Records with builders (`@Data @Builder`)
- Immutable values with `@Value @Builder`
- Custom builders with `@Builder(toBuilder = true)` for convenience copies

**Linting:**
- `@SuppressWarnings({"unused", "ConstantConditions"})` used on service classes to suppress IDE warnings
- `@SuppressWarnings("PMD")` used on test base classes
- Code generally follows Spring and Java conventions with pragmatic exceptions

## Import Organization

**Order (standard Java/Spring):**
1. `java.*` imports (standard library)
2. `javax.*` imports (extensions)
3. Third-party libraries (`org.`, `com.`, `io.`, `lombok.`, `software.amazon.*`)
4. Project imports (`io.github.ericdriggs.*`)
5. Static imports (`static io.github.ericdriggs.reportcard.gen.db.Tables.*`)

**Path Aliases:**
- Not explicitly configured; full package paths used throughout
- Generated JOOQ code: `io.github.ericdriggs.reportcard.gen.db`
- Persist services: `io.github.ericdriggs.reportcard.persist`
- Models: `io.github.ericdriggs.reportcard.model`
- Controllers: `io.github.ericdriggs.reportcard.controller`

## Error Handling

**Patterns:**
- `ResponseStatusException(HttpStatus.*...)` for REST API errors (preferred for Spring Boot)
- `IllegalStateException()` for logical violations and unrecoverable states
- `IllegalArgumentException()` for invalid inputs/preconditions
- `NullPointerException()` for explicit null checks (e.g., `throw new NullPointerException("fieldName")`)
- `RuntimeException()` for wrapping checked exceptions (e.g., IOException wrapped during async operations)
- `UnsupportedOperationException()` for stubs/unimplemented features

**Exception Translation:**
- Checked exceptions from I/O typically wrapped in `RuntimeException` (e.g., in `fileToString()`)
- JOOQ database exceptions handled where appropriate via catch blocks
- Service methods document expected exceptions in class JavaDoc

**Validation:**
- Builder pattern used for object construction with validation in `build()` method
- Validation throws `ResponseStatusException(HttpStatus.BAD_REQUEST, ...)` for user errors
- Example: `StageDetails.StageDetailsBuilder.validateAndSetDefaults()` checks required fields

## Logging

**Framework:** SLF4J with Logback (via Lombok `@Slf4j` annotation)

**Patterns:**
- `@Slf4j` annotation on service and controller classes adds `log` field
- `log.info()` for significant business operations (e.g., "testResult matches dbTestResult")
- `log.warn()` for recoverable issues or edge cases (e.g., "Zero rows set to completed")
- `log.error()` for failure scenarios (e.g., "testResult does not match dbTestResult")
- `log.debug()` for detailed diagnostic info (e.g., field comparison details)
- String concatenation or format strings used (not SLF4J placeholders consistently)

**Examples from codebase:**
```java
log.info("testResult matches dbTestResult. Returning dbTestResult");
log.warn("testSuites.isEmpty()");
log.error(errorString);
log.debug("jobInfo: {}  != request.getJobInfo: {}", jobInfo, stageDetails.getJobInfo());
```

## Comments

**When to Comment:**
- Class-level JavaDoc for public services and models
- TODO/FIXME markers for known issues or deferred work
- Inline comments rare; code should be self-documenting via method/variable names

**JSDoc/TSDoc:**
- JavaDoc used on public methods and classes
- Example from `AbstractPersistService.java`:
  ```java
  /**
   * abstract db service class with connection to DB through DSLContext
   */
  ```
- Example from `TestResultPersistService.java`:
  ```java
  /**
   * Main db service class.
   * For every method which returns a single object, if <code>NULL</code> will throw
   * <code>ResponseStatusException(HttpStatus.NOT_FOUND)</code>
   */
  ```

**TODO/FIXME Usage:**
- Used to mark deferred work (e.g., `//TODO: refactor to Value`)
- Conditional TODOs: `//TOMAYBE: ...` (e.g., `//TOMAYBE: refactor into separate methods`)
- Example: `//TODO: ensure StagePath job.lastRun is not stale`

## Function Design

**Size:**
- Methods average 5-20 lines
- Longer methods for persistence operations (50+ lines acceptable for complex data mapping)
- Shorter methods preferred for controller endpoints (10-15 lines)

**Parameters:**
- Builder pattern used for objects with multiple parameters (e.g., `StageDetails.builder()`)
- Request parameters via Spring `@RequestParam` with descriptions
- Single responsibility: methods accept domain objects or simple types, not parallel hierarchies

**Return Values:**
- `ResponseEntity<T>` for Spring REST controllers
- Domain objects for service methods (`TestResultModel`, `StagePathTestResult`)
- `void` for mutations (updates, inserts)
- Consistently check for null/empty before returning (throw exceptions vs. return null)

## Module Design

**Exports:**
- Service classes use `@Service` Spring annotation (acts as public export)
- Controllers use `@RestController` for REST endpoint export
- Public classes in `model/` package are domain exports
- DTOs defined per-layer (cache DTOs separate from response DTOs)

**Barrel Files:**
- Not used; full package paths imported or explicit static imports from JOOQ tables

## Project Structure Notes

**Persistence Layer:**
- All database operations through JOOQ-generated DAOs/POJOs
- Service methods in `persist/` package extend `AbstractPersistService` or `StagePathPersistService`
- Generated JOOQ code location: `io.github.ericdriggs.reportcard.gen.db`
- Manual schema changes required (no Flyway automatic migration)

**REST API Conventions:**
- Base paths: `/v1/api/{resource}`
- Operations: POST for create (with @RequestParam), GET for read
- Response wrapping: `ResponseEntity<T>` with appropriate status codes
- Error responses: `ResponseEntity<String>` or exception translation to HTTP status

---

*Convention analysis: 2026-01-26*
