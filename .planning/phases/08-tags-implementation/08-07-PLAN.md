---
phase: 08-tags-implementation
plan: 07
type: execute
wave: 4
depends_on: ["08-05", "08-06"]
files_modified:
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/TagQueryController.java
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/TagQueryResponse.java
  - reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/TagQueryControllerTest.java
autonomous: true

must_haves:
  truths:
    - "REST endpoints exist for tag queries at each hierarchy level"
    - "Query parameter 'tags' accepts boolean expression"
    - "Response groups tests by hierarchy with latest run per job"
    - "Invalid expressions return 400 Bad Request"
  artifacts:
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/TagQueryController.java"
      provides: "REST endpoints for tag queries"
      exports: ["searchByTags"]
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/TagQueryResponse.java"
      provides: "Response DTO for tag queries"
      exports: ["TagQueryResponse"]
    - path: "reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/TagQueryControllerTest.java"
      provides: "Controller unit tests"
      min_lines: 80
  key_links:
    - from: "TagQueryController.java"
      to: "TagQueryService.java"
      via: "delegates to service"
      pattern: "tagQueryService\\.find"
    - from: "TagQueryController.java"
      to: "ParseException"
      via: "exception handler for invalid expressions"
      pattern: "@ExceptionHandler.*ParseException"
---

<objective>
Create TagQueryController REST API for tag-based test queries.

Purpose: Expose tag search functionality via REST endpoints at each hierarchy level (company, org, repo, branch, sha).

Output: TagQueryController with endpoints per 07-03-API-DESIGN.md, response DTOs, and unit tests.
</objective>

<execution_context>
@/Users/eric.r.driggs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eric.r.driggs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-tags-investigation/07-03-API-DESIGN.md
@.planning/phases/08-tags-implementation/08-06-SUMMARY.md

# Existing controller patterns
@reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java
@reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/StorageController.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TagQueryResponse DTO</name>
  <files>reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/TagQueryResponse.java</files>
  <action>
    Create response DTO for tag queries following 07-03-API-DESIGN.md structure.

    ```java
    package io.github.ericdriggs.reportcard.model;

    import com.fasterxml.jackson.annotation.JsonInclude;
    import lombok.Builder;
    import lombok.Data;

    import java.time.LocalDateTime;
    import java.util.List;
    import java.util.Map;

    /**
     * Response for tag-based test queries.
     * Tests grouped by hierarchy, latest run per job.
     */
    @Data
    @Builder
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public class TagQueryResponse {

        /**
         * Query parameters that produced this response.
         */
        private QueryInfo query;

        /**
         * Results grouped by remaining hierarchy levels.
         * Structure: branch -> sha -> job -> JobResult
         */
        private Map<String, Map<String, Map<String, JobResult>>> results;

        @Data
        @Builder
        public static class QueryInfo {
            private String scope;
            private String tags;
        }

        @Data
        @Builder
        public static class JobResult {
            private LocalDateTime runDate;
            private List<String> tests;
        }
    }
    ```
  </action>
  <verify>
    Compile check:
    ```bash
    ./gradlew :reportcard-server:compileJava
    ```
  </verify>
  <done>
    - TagQueryResponse with nested structure
    - QueryInfo for echo-back of query params
    - JobResult for per-job results
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TagQueryController</name>
  <files>reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/TagQueryController.java</files>
  <action>
    Create REST controller with endpoints at each hierarchy level.

    ```java
    package io.github.ericdriggs.reportcard.controller;

    import io.github.ericdriggs.reportcard.model.TagQueryResponse;
    import io.github.ericdriggs.reportcard.persist.tags.ParseException;
    import io.github.ericdriggs.reportcard.persist.tags.TagQueryService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.*;

    /**
     * REST controller for tag-based test queries.
     *
     * Query syntax: ?tags=(smoke AND env=prod) OR (regression AND env=staging)
     *
     * Endpoints scope query to hierarchy level in path.
     */
    @RestController
    @RequestMapping("/api/v1")
    public class TagQueryController {

        private final TagQueryService tagQueryService;

        @Autowired
        public TagQueryController(TagQueryService tagQueryService) {
            this.tagQueryService = tagQueryService;
        }

        /**
         * Search all tests by tags (company-wide).
         */
        @GetMapping("/company/{company}/tags/tests")
        public ResponseEntity<TagQueryResponse> searchByTagsCompany(
                @PathVariable String company,
                @RequestParam String tags) {

            return searchByTags(tags, company, null, null, null, null);
        }

        /**
         * Search tests by tags within org scope.
         */
        @GetMapping("/company/{company}/org/{org}/tags/tests")
        public ResponseEntity<TagQueryResponse> searchByTagsOrg(
                @PathVariable String company,
                @PathVariable String org,
                @RequestParam String tags) {

            return searchByTags(tags, company, org, null, null, null);
        }

        /**
         * Search tests by tags within repo scope.
         */
        @GetMapping("/company/{company}/org/{org}/repo/{repo}/tags/tests")
        public ResponseEntity<TagQueryResponse> searchByTagsRepo(
                @PathVariable String company,
                @PathVariable String org,
                @PathVariable String repo,
                @RequestParam String tags) {

            return searchByTags(tags, company, org, repo, null, null);
        }

        /**
         * Search tests by tags within branch scope.
         */
        @GetMapping("/company/{company}/org/{org}/repo/{repo}/branch/{branch}/tags/tests")
        public ResponseEntity<TagQueryResponse> searchByTagsBranch(
                @PathVariable String company,
                @PathVariable String org,
                @PathVariable String repo,
                @PathVariable String branch,
                @RequestParam String tags) {

            return searchByTags(tags, company, org, repo, branch, null);
        }

        /**
         * Search tests by tags within sha scope.
         */
        @GetMapping("/company/{company}/org/{org}/repo/{repo}/branch/{branch}/sha/{sha}/tags/tests")
        public ResponseEntity<TagQueryResponse> searchByTagsSha(
                @PathVariable String company,
                @PathVariable String org,
                @PathVariable String repo,
                @PathVariable String branch,
                @PathVariable String sha,
                @RequestParam String tags) {

            return searchByTags(tags, company, org, repo, branch, sha);
        }

        private ResponseEntity<TagQueryResponse> searchByTags(
                String tagExpression,
                String company,
                String org,
                String repo,
                String branch,
                String sha) {

            // Build scope string for response
            StringBuilder scopeBuilder = new StringBuilder(company);
            if (org != null) scopeBuilder.append("/").append(org);
            if (repo != null) scopeBuilder.append("/").append(repo);
            if (branch != null) scopeBuilder.append("/").append(branch);
            if (sha != null) scopeBuilder.append("/").append(sha);
            String scope = scopeBuilder.toString();

            // Execute query via service
            // Service needs path-to-ID resolution - simplified here
            var results = tagQueryService.findByTagExpressionByPath(
                tagExpression, company, org, repo, branch, sha
            );

            TagQueryResponse response = TagQueryResponse.builder()
                .query(TagQueryResponse.QueryInfo.builder()
                    .scope(scope)
                    .tags(tagExpression)
                    .build())
                .results(results)
                .build();

            return ResponseEntity.ok(response);
        }

        /**
         * Handle parse errors for invalid tag expressions.
         */
        @ExceptionHandler(ParseException.class)
        public ResponseEntity<ErrorResponse> handleParseException(ParseException e) {
            return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(new ErrorResponse("Invalid tag expression", e.getMessage()));
        }

        record ErrorResponse(String error, String message) {}
    }
    ```

    Note: TagQueryService will need a `findByTagExpressionByPath` method that resolves path components to IDs. This may require updates to the service in a minor adjustment.
  </action>
  <verify>
    Compile check:
    ```bash
    ./gradlew :reportcard-server:compileJava
    ```
  </verify>
  <done>
    - Controller with endpoints at all 5 hierarchy levels
    - Tags query parameter accepted
    - Response uses TagQueryResponse structure
    - ParseException handled with 400 response
  </done>
</task>

<task type="auto">
  <name>Task 3: Create controller unit tests</name>
  <files>reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/TagQueryControllerTest.java</files>
  <action>
    Create unit tests for controller using MockMvc.

    ```java
    package io.github.ericdriggs.reportcard.controller;

    import io.github.ericdriggs.reportcard.persist.tags.ParseException;
    import io.github.ericdriggs.reportcard.persist.tags.TagQueryService;
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
    import org.springframework.boot.test.mock.mockito.MockBean;
    import org.springframework.test.web.servlet.MockMvc;

    import java.util.LinkedHashMap;
    import java.util.Map;

    import static org.mockito.ArgumentMatchers.*;
    import static org.mockito.Mockito.*;
    import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
    import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

    @WebMvcTest(TagQueryController.class)
    public class TagQueryControllerTest {

        @Autowired
        private MockMvc mockMvc;

        @MockBean
        private TagQueryService tagQueryService;

        @Test
        void searchByTags_companyLevel_returnsOk() throws Exception {
            when(tagQueryService.findByTagExpressionByPath(
                anyString(), anyString(), isNull(), isNull(), isNull(), isNull()
            )).thenReturn(new LinkedHashMap<>());

            mockMvc.perform(get("/api/v1/company/testco/tags/tests")
                    .param("tags", "smoke"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.query.scope").value("testco"))
                .andExpect(jsonPath("$.query.tags").value("smoke"));
        }

        @Test
        void searchByTags_repoLevel_returnsOk() throws Exception {
            when(tagQueryService.findByTagExpressionByPath(
                anyString(), anyString(), anyString(), anyString(), isNull(), isNull()
            )).thenReturn(new LinkedHashMap<>());

            mockMvc.perform(get("/api/v1/company/testco/org/testorg/repo/testrepo/tags/tests")
                    .param("tags", "smoke AND env=prod"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.query.scope").value("testco/testorg/testrepo"))
                .andExpect(jsonPath("$.query.tags").value("smoke AND env=prod"));
        }

        @Test
        void searchByTags_missingTagsParam_returns400() throws Exception {
            mockMvc.perform(get("/api/v1/company/testco/tags/tests"))
                .andExpect(status().isBadRequest());
        }

        @Test
        void searchByTags_invalidExpression_returns400() throws Exception {
            when(tagQueryService.findByTagExpressionByPath(
                anyString(), anyString(), isNull(), isNull(), isNull(), isNull()
            )).thenThrow(new ParseException("Unexpected token", 0));

            mockMvc.perform(get("/api/v1/company/testco/tags/tests")
                    .param("tags", "AND smoke"))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.error").value("Invalid tag expression"));
        }

        @Test
        void searchByTags_complexExpression_acceptsUrlEncodedSyntax() throws Exception {
            when(tagQueryService.findByTagExpressionByPath(
                anyString(), anyString(), isNull(), isNull(), isNull(), isNull()
            )).thenReturn(new LinkedHashMap<>());

            // URL-encoded: (smoke OR regression) AND env=prod
            mockMvc.perform(get("/api/v1/company/testco/tags/tests")
                    .param("tags", "(smoke OR regression) AND env=prod"))
                .andExpect(status().isOk());
        }

        @Test
        void searchByTags_allHierarchyLevels_includeScopeInResponse() throws Exception {
            when(tagQueryService.findByTagExpressionByPath(
                anyString(), anyString(), anyString(), anyString(), anyString(), anyString()
            )).thenReturn(new LinkedHashMap<>());

            mockMvc.perform(get("/api/v1/company/co/org/o/repo/r/branch/b/sha/s/tags/tests")
                    .param("tags", "smoke"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.query.scope").value("co/o/r/b/s"));
        }
    }
    ```
  </action>
  <verify>
    Run tests:
    ```bash
    ./gradlew :reportcard-server:test --tests "*.TagQueryControllerTest" --info
    ```
  </verify>
  <done>
    - Tests verify each hierarchy endpoint
    - Missing tags param returns 400
    - Invalid expression returns 400 with error message
    - Complex expressions accepted
    - Scope included in response
  </done>
</task>

</tasks>

<verification>
Full controller test run:
```bash
./gradlew :reportcard-server:test --tests "*.TagQueryControllerTest" --info
```

All tests should pass, verifying REST API contract.
</verification>

<success_criteria>
1. TagQueryController exists with 5 hierarchy-level endpoints
2. Tags query parameter accepted as boolean expression
3. Response structure matches 07-03-API-DESIGN.md
4. Invalid expressions return 400 Bad Request
5. Missing tags param returns 400
6. All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-tags-implementation/08-07-SUMMARY.md`
</output>
