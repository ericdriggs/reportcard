---
phase: 08-tags-implementation
plan: 04
type: tdd
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateCucumberConverter.java
  - reportcard-model/src/test/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateCucumberConverterTest.java
autonomous: true

must_haves:
  truths:
    - "Feature maps to TestSuiteModel"
    - "Scenario maps to TestCaseModel"
    - "Tags extracted at both feature and scenario levels"
    - "Status derived from step results (any failed step = failure)"
    - "Time summed from scenario durations"
  artifacts:
    - path: "reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateCucumberConverter.java"
      provides: "Karate JSON to Reportcard model converter"
      exports: ["fromCucumberJson", "fromFeature", "fromScenario"]
    - path: "reportcard-model/src/test/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateCucumberConverterTest.java"
      provides: "Converter unit tests"
      min_lines: 200
  key_links:
    - from: "KarateCucumberConverter.java"
      to: "KarateTagExtractor.java"
      via: "uses for tag extraction"
      pattern: "KarateTagExtractor|extractTags"
    - from: "KarateCucumberConverter.java"
      to: "TestSuiteModel.java"
      via: "produces TestSuiteModel instances"
      pattern: "TestSuiteModel\\.builder"
---

<objective>
Implement full Karate/Cucumber JSON to Reportcard model converter using TDD approach.

Purpose: Create a converter similar to JunitConvertersUtil that maps Karate JSON structure to TestSuiteModel/TestCaseModel. This enables Karate JSON to be the primary source of truth when uploaded.

Output: KarateCucumberConverter class with methods to convert features to suites and scenarios to test cases, plus comprehensive unit tests.
</objective>

<execution_context>
@/Users/eric.r.driggs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eric.r.driggs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-tags-investigation/07-01-TAG-MAPPING-SPEC.md

# Existing converter pattern to follow
@reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/junit/JunitConvertersUtil.java

# Model classes
@reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/TestSuiteModel.java
@reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/TestCaseModel.java
@reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/TestStatus.java
</context>

<feature>
  <name>KarateCucumberConverter</name>
  <files>
    reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateCucumberConverter.java
    reportcard-model/src/test/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateCucumberConverterTest.java
  </files>
  <behavior>
    Karate/Cucumber JSON structure:
    ```json
    [
      {
        "name": "feature-name.feature",
        "tags": [{"name": "@smoke", "line": 1}],
        "elements": [
          {
            "name": "scenario name",
            "type": "scenario",
            "tags": [{"name": "@env=prod", "line": 3}],
            "steps": [
              {"result": {"status": "passed", "duration": 123456789}},
              {"result": {"status": "failed", "error_message": "..."}}
            ]
          }
        ]
      }
    ]
    ```

    Mapping rules:
    - Feature → TestSuiteModel
      - feature.name → suite.name
      - feature.tags → suite.tags (via KarateTagExtractor)
      - feature.elements → suite.testCases
      - Aggregate status from test cases
      - Sum time from test cases

    - Scenario (element) → TestCaseModel
      - element.name → testCase.name
      - element.tags → testCase.tags (via KarateTagExtractor)
      - element.type used to filter (only "scenario" or "scenario_outline")
      - Status from steps: all passed = SUCCESS, any failed = FAILURE, any error = ERROR, all skipped = SKIPPED
      - Time from sum of step durations (nanoseconds → seconds)

    Edge cases:
    - Empty feature (no elements) → empty testCases list
    - Missing tags → empty tags list
    - Missing steps → SKIPPED status
    - Scenario outline → treat as single test case (not expanded)
    - Background elements → skip (type != "scenario")
    - Null/missing duration → 0
  </behavior>
  <implementation>
    ```java
    package io.github.ericdriggs.reportcard.model.converter.karate;

    import com.fasterxml.jackson.databind.JsonNode;
    import com.fasterxml.jackson.databind.ObjectMapper;
    import io.github.ericdriggs.reportcard.mappers.SharedObjectMappers;
    import io.github.ericdriggs.reportcard.model.*;
    import lombok.extern.slf4j.Slf4j;

    import java.math.BigDecimal;
    import java.math.RoundingMode;
    import java.util.*;

    /**
     * Converts Karate/Cucumber JSON to Reportcard model.
     * Maps Feature → TestSuiteModel, Scenario → TestCaseModel.
     */
    @Slf4j
    public class KarateCucumberConverter {

        private static final ObjectMapper mapper = SharedObjectMappers.ignoreUnknownObjectMapper;
        private static final KarateTagExtractor tagExtractor = new KarateTagExtractor();
        private static final BigDecimal NANOS_PER_SECOND = new BigDecimal("1000000000");

        /**
         * Parse Karate/Cucumber JSON array into list of TestSuiteModels.
         *
         * @param jsonContent JSON array of features
         * @return list of TestSuiteModels, one per feature
         */
        public static List<TestSuiteModel> fromCucumberJson(String jsonContent) {
            if (jsonContent == null || jsonContent.isBlank()) {
                return List.of();
            }

            try {
                JsonNode root = mapper.readTree(jsonContent);
                if (!root.isArray()) {
                    log.warn("Cucumber JSON is not an array");
                    return List.of();
                }

                List<TestSuiteModel> suites = new ArrayList<>();
                for (JsonNode feature : root) {
                    suites.add(fromFeature(feature));
                }
                return suites;
            } catch (Exception e) {
                log.error("Failed to parse Cucumber JSON", e);
                return List.of();
            }
        }

        /**
         * Convert a single feature node to TestSuiteModel.
         */
        public static TestSuiteModel fromFeature(JsonNode feature) {
            String name = feature.path("name").asText("");
            List<String> tags = tagExtractor.extractTags(feature.path("tags"));

            List<TestCaseModel> testCases = new ArrayList<>();
            JsonNode elements = feature.path("elements");
            if (elements.isArray()) {
                for (JsonNode element : elements) {
                    String type = element.path("type").asText("");
                    // Only process scenarios and scenario outlines, skip backgrounds
                    if ("scenario".equals(type) || "scenario_outline".equals(type)) {
                        testCases.add(fromScenario(element));
                    }
                }
            }

            // Calculate aggregates
            int tests = testCases.size();
            int errors = 0, failures = 0, skipped = 0;
            BigDecimal totalTime = BigDecimal.ZERO;
            boolean isSuccess = true;

            for (TestCaseModel tc : testCases) {
                if (tc.getTime() != null) {
                    totalTime = totalTime.add(tc.getTime());
                }
                TestStatus status = tc.getTestStatus();
                if (status == TestStatus.ERROR) {
                    errors++;
                    isSuccess = false;
                } else if (status == TestStatus.FAILURE) {
                    failures++;
                    isSuccess = false;
                } else if (status == TestStatus.SKIPPED) {
                    skipped++;
                }
            }

            return TestSuiteModel.builder()
                .name(name)
                .tags(tags)
                .testCases(testCases)
                .tests(tests)
                .error(errors)
                .failure(failures)
                .skipped(skipped)
                .isSuccess(isSuccess && tests > 0)
                .hasSkip(skipped > 0 || tests == 0)
                .time(totalTime)
                .build();
        }

        /**
         * Convert a scenario element to TestCaseModel.
         */
        public static TestCaseModel fromScenario(JsonNode scenario) {
            String name = scenario.path("name").asText("");
            List<String> tags = tagExtractor.extractTags(scenario.path("tags"));

            // Determine status and time from steps
            TestStatus status = TestStatus.SUCCESS;
            BigDecimal totalNanos = BigDecimal.ZERO;
            List<TestCaseFaultModel> faults = new ArrayList<>();
            boolean hasSteps = false;

            JsonNode steps = scenario.path("steps");
            if (steps.isArray()) {
                for (JsonNode step : steps) {
                    hasSteps = true;
                    JsonNode result = step.path("result");
                    String stepStatus = result.path("status").asText("skipped");
                    long duration = result.path("duration").asLong(0);
                    totalNanos = totalNanos.add(BigDecimal.valueOf(duration));

                    // Status escalation: skipped < success < failure < error
                    if ("failed".equals(stepStatus)) {
                        if (status != TestStatus.ERROR) {
                            status = TestStatus.FAILURE;
                        }
                        // Capture error message if present
                        String errorMessage = result.path("error_message").asText(null);
                        if (errorMessage != null) {
                            faults.add(TestCaseFaultModel.builder()
                                .faultContextFk(FaultContext.FAILURE.getFaultContextId())
                                .message(step.path("name").asText(""))
                                .value(errorMessage)
                                .build());
                        }
                    } else if ("undefined".equals(stepStatus) || "pending".equals(stepStatus)) {
                        if (status == TestStatus.SUCCESS) {
                            status = TestStatus.SKIPPED;
                        }
                    } else if ("skipped".equals(stepStatus)) {
                        if (status == TestStatus.SUCCESS) {
                            status = TestStatus.SKIPPED;
                        }
                    }
                    // "passed" keeps current status
                }
            }

            if (!hasSteps) {
                status = TestStatus.SKIPPED;
            }

            // Convert nanoseconds to seconds
            BigDecimal timeSeconds = totalNanos.divide(NANOS_PER_SECOND, 3, RoundingMode.HALF_UP);

            return TestCaseModel.builder()
                .name(name)
                .tags(tags)
                .testStatus(status)
                .testCaseFaults(faults)
                .time(timeSeconds)
                .build();
        }

        /**
         * Collect all tags from all suites and test cases (flattened, deduplicated).
         * Used for storing in test_result.tags column.
         */
        public static List<String> collectAllTags(List<TestSuiteModel> suites) {
            Set<String> allTags = new LinkedHashSet<>();
            for (TestSuiteModel suite : suites) {
                if (suite.getTags() != null) {
                    allTags.addAll(suite.getTags());
                }
                for (TestCaseModel tc : suite.getTestCases()) {
                    if (tc.getTags() != null) {
                        allTags.addAll(tc.getTags());
                    }
                }
            }
            return new ArrayList<>(allTags);
        }
    }
    ```
  </implementation>
</feature>

<verification>
Run tests:
```bash
./gradlew :reportcard-model:test --tests "*.KarateCucumberConverterTest" --info
```

All tests must pass, covering:
- Feature to TestSuiteModel conversion
- Scenario to TestCaseModel conversion
- Tag extraction at both levels
- Status determination from steps
- Time calculation (nanoseconds to seconds)
- Edge cases (empty, missing fields, etc.)
</verification>

<success_criteria>
1. fromCucumberJson parses JSON array to List<TestSuiteModel>
2. Feature.name → TestSuiteModel.name
3. Feature.tags → TestSuiteModel.tags (via KarateTagExtractor)
4. Scenario.name → TestCaseModel.name
5. Scenario.tags → TestCaseModel.tags (via KarateTagExtractor)
6. Status derived from steps (failed step = FAILURE)
7. Time calculated from step durations
8. collectAllTags returns flattened, deduplicated tags
9. All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-tags-implementation/08-04-SUMMARY.md`
</output>
