---
phase: 08-tags-implementation
plan: 05
type: execute
wave: 3
depends_on: ["08-01", "08-02", "08-03"]
files_modified:
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/StagePathPersistService.java
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/converter/JunitSurefireXmlParseUtil.java
autonomous: true

must_haves:
  truths:
    - "Karate JSON upload extracts tags at feature and scenario levels"
    - "Tags stored in TestSuiteModel.tags and TestCaseModel.tags"
    - "Flattened tags stored in test_result.tags column"
    - "Existing JUnit-only uploads continue working (tags remain null)"
  artifacts:
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/StagePathPersistService.java"
      provides: "Integration of tag extraction into persist flow"
      contains: "setTags"
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/converter/JunitSurefireXmlParseUtil.java"
      provides: "Karate JSON to model conversion with tags"
      contains: "extractTags"
  key_links:
    - from: "StagePathPersistService.java"
      to: "KarateTagExtractor.java"
      via: "calls extractTags during Karate processing"
      pattern: "KarateTagExtractor|extractTags"
    - from: "TestResultRecord"
      to: "test_result.tags"
      via: "JOOQ setTags"
      pattern: "setTags.*JSON"
---

<objective>
Integrate tag extraction into the Karate JSON upload flow, storing tags at all three levels.

Purpose: When Karate JSON is uploaded, tags must be extracted and stored in TestSuiteModel (feature), TestCaseModel (scenario), and test_result.tags (flattened for querying).

Output: Updated persistence layer that extracts and stores tags during Karate uploads.
</objective>

<execution_context>
@/Users/eric.r.driggs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eric.r.driggs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-tags-investigation/07-01-TAG-MAPPING-SPEC.md
@.planning/phases/08-tags-implementation/08-01-SUMMARY.md
@.planning/phases/08-tags-implementation/08-02-SUMMARY.md
@.planning/phases/08-tags-implementation/08-03-SUMMARY.md

# Existing Karate processing
@reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/StagePathPersistService.java
@reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/JunitSurefireXmlParseUtil.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Karate JSON to model conversion with tags extraction</name>
  <files>reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/JunitSurefireXmlParseUtil.java</files>
  <action>
    Update the Karate JSON parsing to extract tags at feature and scenario levels.

    Find the method that converts Karate/Cucumber JSON to TestSuiteModel/TestCaseModel (likely something like `fromCucumberJson` or similar).

    Add tag extraction using KarateTagExtractor:

    ```java
    import io.github.ericdriggs.reportcard.model.converter.karate.KarateTagExtractor;

    // In the method that processes Karate JSON features:
    private static final KarateTagExtractor tagExtractor = new KarateTagExtractor();

    // When creating TestSuiteModel from feature:
    List<String> featureTags = tagExtractor.extractTags(featureNode.path("tags"));
    testSuiteModel.setTags(featureTags);
    allTags.addAll(featureTags);  // Collect for flattening

    // When creating TestCaseModel from scenario (element):
    List<String> scenarioTags = tagExtractor.extractTags(elementNode.path("tags"));
    testCaseModel.setTags(scenarioTags);
    allTags.addAll(scenarioTags);  // Collect for flattening
    ```

    Return or make accessible the flattened allTags set for storage in test_result.tags.

    Note: If the existing parsing doesn't support easy tag extraction, create a new method specifically for Karate JSON that handles tags. JUnit XML doesn't have tags, so existing XML parsing should not be modified.
  </action>
  <verify>
    Compile check:
    ```bash
    ./gradlew :reportcard-model:compileJava
    ```
  </verify>
  <done>
    - Tag extraction integrated into Karate JSON parsing
    - Feature tags stored in TestSuiteModel.tags
    - Scenario tags stored in TestCaseModel.tags
    - Flattened tag list returned/accessible for test_result storage
  </done>
</task>

<task type="auto">
  <name>Task 2: Update persistence to store flattened tags in test_result</name>
  <files>reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/StagePathPersistService.java</files>
  <action>
    Update the test result persistence to store the flattened tags JSON.

    In the method that creates/updates TestResult records (likely in `insertTestResult` or similar):

    ```java
    import com.fasterxml.jackson.databind.ObjectMapper;
    import io.github.ericdriggs.reportcard.mappers.SharedObjectMappers;

    // After building TestResultModel with TestSuiteModels:
    // Collect all tags from all suites and test cases
    Set<String> allTags = new LinkedHashSet<>();
    for (TestSuiteModel suite : testResult.getTestSuites()) {
        if (suite.getTags() != null) {
            allTags.addAll(suite.getTags());
        }
        for (TestCaseModel testCase : suite.getTestCases()) {
            if (testCase.getTags() != null) {
                allTags.addAll(testCase.getTags());
            }
        }
    }

    // Convert to JSON string for storage
    String tagsJson = null;
    if (!allTags.isEmpty()) {
        tagsJson = SharedObjectMappers.ignoreUnknownObjectMapper
            .writeValueAsString(new ArrayList<>(allTags));
    }

    // Set on JOOQ record
    testResultRecord.setTags(JSON.json(tagsJson));
    ```

    Note: JOOQ's JSON type may require `JSON.json()` wrapper or direct string assignment depending on version. Check existing patterns in the codebase for JSON column handling.
  </action>
  <verify>
    Compile check:
    ```bash
    ./gradlew :reportcard-server:compileJava
    ```
  </verify>
  <done>
    - StagePathPersistService collects flattened tags
    - Tags stored as JSON array string in test_result.tags
    - Existing JUnit-only flow unaffected (tags = null)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit test for tag storage flow</name>
  <files>reportcard-model/src/test/java/io/github/ericdriggs/reportcard/model/converter/KarateJsonTagExtractionTest.java</files>
  <action>
    Create a unit test that verifies tags are extracted correctly from Karate JSON.

    ```java
    package io.github.ericdriggs.reportcard.model.converter;

    import io.github.ericdriggs.reportcard.model.TestCaseModel;
    import io.github.ericdriggs.reportcard.model.TestSuiteModel;
    import io.github.ericdriggs.reportcard.xml.ResourceReader;
    import org.junit.jupiter.api.Test;

    import java.util.List;
    import java.util.Set;
    import java.util.LinkedHashSet;

    import static org.junit.jupiter.api.Assertions.*;

    /**
     * Tests Karate JSON tag extraction integration.
     */
    public class KarateJsonTagExtractionTest {

        @Test
        void karateJson_extractsFeatureTags() {
            // Load sample Karate JSON with tags
            String karateJson = ResourceReader.resourceAsString(
                "format-samples/cucumber-json/cucumber-json-with-tags.json");

            List<TestSuiteModel> suites = JunitSurefireXmlParseUtil.fromCucumberJson(karateJson);

            // Verify feature-level tags
            assertFalse(suites.isEmpty());
            TestSuiteModel suite = suites.get(0);
            assertNotNull(suite.getTags());
            // Actual assertions depend on test data
        }

        @Test
        void karateJson_extractsScenarioTags() {
            String karateJson = ResourceReader.resourceAsString(
                "format-samples/cucumber-json/cucumber-json-with-tags.json");

            List<TestSuiteModel> suites = JunitSurefireXmlParseUtil.fromCucumberJson(karateJson);

            // Verify scenario-level tags
            TestSuiteModel suite = suites.get(0);
            assertFalse(suite.getTestCases().isEmpty());
            TestCaseModel testCase = suite.getTestCases().get(0);
            assertNotNull(testCase.getTags());
        }

        @Test
        void collectAllTags_flattensAndDeduplicates() {
            // Test the flattening logic that would be used for test_result.tags
            TestSuiteModel suite = TestSuiteModel.builder()
                .name("test.feature")
                .tags(List.of("smoke", "regression"))
                .testCases(List.of(
                    TestCaseModel.builder()
                        .name("scenario1")
                        .tags(List.of("smoke", "env=staging"))
                        .build()
                ))
                .build();

            Set<String> allTags = new LinkedHashSet<>();
            allTags.addAll(suite.getTags());
            for (TestCaseModel tc : suite.getTestCases()) {
                allTags.addAll(tc.getTags());
            }

            // Should be deduplicated: smoke appears once
            assertEquals(3, allTags.size());
            assertTrue(allTags.contains("smoke"));
            assertTrue(allTags.contains("regression"));
            assertTrue(allTags.contains("env=staging"));
        }
    }
    ```

    Note: May need to create test resource file with Karate JSON that includes tags. Use the format from 07-01-TAG-MAPPING-SPEC.md.
  </action>
  <verify>
    Run tests:
    ```bash
    ./gradlew :reportcard-model:test --tests "*.KarateJsonTagExtractionTest" --info
    ```
  </verify>
  <done>
    - Unit test verifies tag extraction from Karate JSON
    - Test covers feature and scenario level extraction
    - Test covers deduplication in flattening
  </done>
</task>

</tasks>

<verification>
Full build with tests:
```bash
./gradlew build -x integrationTest
```

Should complete with tag extraction integrated into Karate flow.
</verification>

<success_criteria>
1. Karate JSON parsing extracts tags at feature and scenario levels
2. TestSuiteModel.tags populated from feature tags
3. TestCaseModel.tags populated from scenario tags
4. Flattened tags collected for test_result storage
5. test_result.tags stores JSON array of deduplicated tags
6. JUnit-only uploads unaffected (tags remain null)
7. Unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-tags-implementation/08-05-SUMMARY.md`
</output>
