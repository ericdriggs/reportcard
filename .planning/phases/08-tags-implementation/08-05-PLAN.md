---
phase: 08-tags-implementation
plan: 05
type: execute
wave: 3
depends_on: ["08-03", "08-04"]
files_modified:
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/util/KarateTarGzUtil.java
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/TestResultPersistService.java
autonomous: true

must_haves:
  truths:
    - "Karate JSON is primary source when present"
    - "JUnit XML used only when no Karate JSON"
    - "Tags stored in test_result.tags column as JSON array"
    - "Backwards compatible with JUnit-only uploads"
  artifacts:
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java"
      provides: "Updated controller using Karate as primary"
      contains: "KarateCucumberConverter"
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/util/KarateTarGzUtil.java"
      provides: "Extract full Karate JSON (not just summary)"
      contains: "extractCucumberJson"
  key_links:
    - from: "JunitController.java"
      to: "KarateCucumberConverter.java"
      via: "uses for Karate JSON parsing"
      pattern: "KarateCucumberConverter\\.fromCucumberJson"
    - from: "TestResultRecord"
      to: "test_result.tags"
      via: "JOOQ setTags"
      pattern: "setTags"
---

<objective>
Integrate KarateCucumberConverter into the upload flow, making Karate JSON the primary source of truth when present.

Purpose: When Karate JSON is uploaded, use it as the primary source for test structure (features → suites, scenarios → cases) and tags. Fall back to JUnit XML only when no Karate JSON is provided.

Output: Updated controller and persistence layer that uses Karate as primary source, with tags stored in test_result.tags.
</objective>

<execution_context>
@/Users/eric.r.driggs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eric.r.driggs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-tags-investigation/07-01-TAG-MAPPING-SPEC.md
@.planning/phases/08-tags-implementation/08-04-SUMMARY.md

# Current controller implementation
@reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java
@reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/util/KarateTarGzUtil.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update KarateTarGzUtil to extract Cucumber JSON</name>
  <files>reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/util/KarateTarGzUtil.java</files>
  <action>
    Add method to extract the full Cucumber JSON file (not just karate-summary-json.txt).

    The Karate tar.gz contains multiple JSON files:
    - `karate-summary-json.txt` (timing summary - already extracted)
    - `*.json` files (feature results - Cucumber JSON format)

    Add new method:

    ```java
    /**
     * Extracts Cucumber JSON content from karate.tar.gz.
     * Looks for JSON files that are NOT karate-summary-json.txt.
     * Returns concatenated JSON array of all feature results.
     *
     * @param tarGz the uploaded tar.gz file
     * @return JSON array string of feature results, or null if not found
     */
    public static String extractCucumberJson(MultipartFile tarGz) {
        if (tarGz == null || tarGz.isEmpty()) {
            return null;
        }

        try (InputStream is = tarGz.getInputStream();
             GZIPInputStream gzis = new GZIPInputStream(is);
             TarArchiveInputStream tais = new TarArchiveInputStream(gzis)) {

            List<String> jsonContents = new ArrayList<>();
            TarArchiveEntry entry;

            while ((entry = tais.getNextTarEntry()) != null) {
                if (entry.isDirectory()) continue;

                String name = entry.getName();
                // Skip summary file, look for feature JSON files
                if (name.endsWith(".json") && !name.contains("karate-summary")) {
                    String content = new String(tais.readAllBytes(), StandardCharsets.UTF_8);
                    // Cucumber JSON is an array - we may have multiple files
                    jsonContents.add(content);
                }
            }

            if (jsonContents.isEmpty()) {
                return null;
            }

            // If single file, return as-is (already an array)
            if (jsonContents.size() == 1) {
                return jsonContents.get(0);
            }

            // Multiple files: merge arrays
            // Each file is a JSON array, combine into single array
            ObjectMapper mapper = SharedObjectMappers.ignoreUnknownObjectMapper;
            ArrayNode combined = mapper.createArrayNode();
            for (String json : jsonContents) {
                JsonNode node = mapper.readTree(json);
                if (node.isArray()) {
                    for (JsonNode elem : node) {
                        combined.add(elem);
                    }
                }
            }
            return mapper.writeValueAsString(combined);

        } catch (Exception e) {
            log.warn("Failed to extract Cucumber JSON from tar.gz", e);
            return null;
        }
    }
    ```
  </action>
  <verify>
    Compile check:
    ```bash
    ./gradlew :reportcard-server:compileJava
    ```
  </verify>
  <done>
    - extractCucumberJson method added
    - Finds feature JSON files (not summary)
    - Handles single or multiple JSON files
    - Returns combined JSON array
  </done>
</task>

<task type="auto">
  <name>Task 2: Update JunitController to use Karate as primary source</name>
  <files>reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java</files>
  <action>
    Modify doPostStageJunitStorageTarGZ to use Karate JSON as primary source when present.

    Current flow:
    1. Parse JUnit if present → TestResultModel
    2. Process Karate timing separately

    New flow:
    1. If Karate present: Parse Karate JSON → TestResultModel (with tags)
    2. Else if JUnit present: Parse JUnit → TestResultModel (no tags)
    3. Store test result with tags in test_result.tags column

    Update the method:

    ```java
    public StagePathStorageResultCountResponse doPostStageJunitStorageTarGZ(JunitHtmlPostRequest req) {
        boolean hasJunit = req.getJunitXmls() != null && !req.getJunitXmls().isEmpty();
        boolean hasKarate = req.getKarateTarGz() != null && !req.getKarateTarGz().isEmpty();

        if (!hasJunit && !hasKarate) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
                "At least one of junit.tar.gz or karate.tar.gz must be provided");
        }

        // CHANGED: Karate is primary source when present
        TestResultModel testResultModel;
        List<String> allTags = null;

        if (hasKarate) {
            // Extract Cucumber JSON from karate.tar.gz
            String cucumberJson = KarateTarGzUtil.extractCucumberJson(req.getKarateTarGz());
            if (cucumberJson != null && !cucumberJson.isBlank()) {
                List<TestSuiteModel> suites = KarateCucumberConverter.fromCucumberJson(cucumberJson);
                testResultModel = new TestResultModel(suites);
                allTags = KarateCucumberConverter.collectAllTags(suites);
            } else {
                // Karate tar.gz present but no Cucumber JSON found - fall back to JUnit
                log.warn("Karate tar.gz provided but no Cucumber JSON found, falling back to JUnit");
                if (hasJunit) {
                    List<String> testXmlContents = TestXmlTarGzUtil.getFileContentsFromTarGz(req.getJunitXmls());
                    testResultModel = JunitSurefireXmlParseUtil.parseTestXml(testXmlContents);
                } else {
                    testResultModel = new TestResultModel();
                    testResultModel.setTestSuites(new ArrayList<>());
                }
            }
        } else {
            // JUnit only (existing behavior)
            List<String> testXmlContents = TestXmlTarGzUtil.getFileContentsFromTarGz(req.getJunitXmls());
            testResultModel = JunitSurefireXmlParseUtil.parseTestXml(testXmlContents);
        }

        // Insert test result (updated to accept tags)
        StagePathTestResult stagePathTestResult = testResultPersistService.insertTestResult(
            req.getStageDetails(), testResultModel, allTags);

        // ... rest of method unchanged (timing, S3 storage) ...
    }
    ```

    Add import for KarateCucumberConverter.
  </action>
  <verify>
    Compile check:
    ```bash
    ./gradlew :reportcard-server:compileJava
    ```
  </verify>
  <done>
    - Controller uses Karate as primary when present
    - Falls back to JUnit when no Karate
    - Collects tags from Karate-sourced model
    - Passes tags to persistence layer
  </done>
</task>

<task type="auto">
  <name>Task 3: Update TestResultPersistService to store tags</name>
  <files>reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/TestResultPersistService.java</files>
  <action>
    Update insertTestResult to accept and store tags in test_result.tags column.

    Add overloaded method or modify existing:

    ```java
    /**
     * Insert test result with optional tags.
     *
     * @param stageDetails stage path details
     * @param testResultModel the test result model
     * @param tags flattened list of tags (null for JUnit-only uploads)
     * @return the inserted test result with stage path
     */
    public StagePathTestResult insertTestResult(
            StageDetails stageDetails,
            TestResultModel testResultModel,
            List<String> tags) {

        // ... existing logic to create/get stage path ...

        // Create test result record
        TestResultRecord record = dsl.newRecord(TEST_RESULT);
        // ... existing field population ...

        // NEW: Store tags as JSON array
        if (tags != null && !tags.isEmpty()) {
            try {
                String tagsJson = SharedObjectMappers.ignoreUnknownObjectMapper
                    .writeValueAsString(tags);
                record.setTags(JSON.json(tagsJson));
            } catch (JsonProcessingException e) {
                log.warn("Failed to serialize tags to JSON", e);
            }
        }

        // ... rest of existing logic ...
    }
    ```

    Keep existing no-args version for backwards compatibility:
    ```java
    public StagePathTestResult insertTestResult(
            StageDetails stageDetails,
            TestResultModel testResultModel) {
        return insertTestResult(stageDetails, testResultModel, null);
    }
    ```
  </action>
  <verify>
    Compile check:
    ```bash
    ./gradlew :reportcard-server:compileJava
    ```
  </verify>
  <done>
    - insertTestResult accepts optional tags parameter
    - Tags stored as JSON array in test_result.tags
    - Backwards compatible (null tags = no change)
  </done>
</task>

<task type="auto">
  <name>Task 4: Add integration test for Karate-primary flow</name>
  <files>reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/KaratePrimarySourceTest.java</files>
  <action>
    Create integration test verifying Karate JSON is used as primary source.

    ```java
    package io.github.ericdriggs.reportcard.controller;

    import io.github.ericdriggs.reportcard.controller.model.JunitHtmlPostRequest;
    import io.github.ericdriggs.reportcard.model.StageDetails;
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.mock.web.MockMultipartFile;
    import org.springframework.test.context.ActiveProfiles;

    import static org.junit.jupiter.api.Assertions.*;

    /**
     * Integration test verifying Karate JSON is primary source when both provided.
     */
    @SpringBootTest
    @ActiveProfiles("test")
    public class KaratePrimarySourceTest {

        @Autowired
        private JunitController junitController;

        @Test
        void whenKarateProvided_usesKarateAsSource() {
            // Create Karate tar.gz with known feature/scenario names
            // Create JUnit tar.gz with DIFFERENT names
            // Upload both
            // Verify test_result contains Karate names, not JUnit names
        }

        @Test
        void whenKarateProvided_storesTags() {
            // Create Karate tar.gz with tags
            // Upload
            // Verify test_result.tags contains expected tags
        }

        @Test
        void whenOnlyJunit_noTagsStored() {
            // Create JUnit tar.gz only
            // Upload
            // Verify test_result.tags is null
        }
    }
    ```

    Note: Full test implementation depends on test resource files and may need adjustment based on available test data.
  </action>
  <verify>
    Compile check (tests may not run without resources):
    ```bash
    ./gradlew :reportcard-server:compileTestJava
    ```
  </verify>
  <done>
    - Integration test structure created
    - Tests verify Karate as primary source
    - Tests verify tags storage
    - Tests verify JUnit fallback
  </done>
</task>

</tasks>

<verification>
Full build with server module:
```bash
./gradlew :reportcard-server:build -x integrationTest
```

Should complete with Karate-primary flow integrated.
</verification>

<success_criteria>
1. KarateTarGzUtil.extractCucumberJson finds feature JSON files
2. Controller uses Karate as primary source when present
3. Falls back to JUnit when no Karate Cucumber JSON
4. Tags collected and passed to persistence layer
5. test_result.tags populated with JSON array
6. Backwards compatible (JUnit-only uploads still work)
7. Integration tests verify behavior
</success_criteria>

<output>
After completion, create `.planning/phases/08-tags-implementation/08-05-SUMMARY.md`
</output>
