---
phase: 02-karate-parser
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateSummary.java
  - reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateConvertersUtil.java
  - reportcard-model/src/test/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateConvertersUtilTest.java
  - reportcard-model/src/test/resources/format-samples/karate/karate-summary-valid.json
  - reportcard-model/src/test/resources/format-samples/karate/karate-summary-malformed.json
autonomous: true

must_haves:
  truths:
    - "KarateConvertersUtil.parseKarateSummary(validJson) returns populated KarateSummary object"
    - "KarateConvertersUtil.parseResultDate(dateString) returns LocalDateTime for valid Karate format"
    - "KarateConvertersUtil.calculateStartTime(endTime, elapsedMillis) returns correct start time"
    - "Malformed JSON returns null (not exception)"
    - "Invalid date format returns null (not exception)"
    - "Negative elapsedTime treated as null"
  artifacts:
    - path: "reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateSummary.java"
      provides: "POJO for karate-summary-json.txt structure"
      contains: "class KarateSummary"
    - path: "reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateConvertersUtil.java"
      provides: "Static utility methods for parsing Karate JSON"
      exports: ["parseKarateSummary", "parseResultDate", "calculateStartTime"]
    - path: "reportcard-model/src/test/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateConvertersUtilTest.java"
      provides: "Unit tests for parser"
      min_lines: 50
  key_links:
    - from: "KarateConvertersUtil.java"
      to: "SharedObjectMappers"
      via: "readValueOrDefault for JSON parsing"
      pattern: "SharedObjectMappers\\.readValueOrDefault"
    - from: "KarateConvertersUtil.java"
      to: "KarateSummary.java"
      via: "JSON deserialization target"
      pattern: "KarateSummary\\.class"
---

<objective>
Create a Karate JSON summary parser that extracts timing data (elapsedTime, resultDate) to calculate start_time and end_time for run records.

Purpose: Enable Phase 3 to persist wall-clock job duration when Karate test results are uploaded. The parser gracefully handles malformed input by returning nulls and logging warnings (no exceptions).

Output: KarateConvertersUtil utility class with static methods for parsing Karate summary JSON, plus comprehensive unit tests.
</objective>

<execution_context>
@/Users/eric.r.driggs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eric.r.driggs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-karate-parser/02-CONTEXT.md
@.planning/phases/02-karate-parser/02-RESEARCH.md

Existing patterns to follow:
@reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/surefire/SurefireConvertersUtil.java
@reportcard-model/src/main/java/io/github/ericdriggs/reportcard/mappers/SharedObjectMappers.java
@reportcard-model/src/main/java/io/github/ericdriggs/reportcard/xml/ResourceReader.java
@reportcard-model/src/test/java/io/github/ericdriggs/reportcard/model/converter/JunitSurefireXmlParseUtilTest.java

Sample Karate JSON to parse:
@cucumber-json/karate-reports/karate-summary-json.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KarateSummary POJO and KarateConvertersUtil parser</name>
  <files>
    reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateSummary.java
    reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateConvertersUtil.java
  </files>
  <action>
Create the karate subpackage under model/converter/ with two classes:

**KarateSummary.java** - POJO matching karate-summary-json.txt structure:
```java
package io.github.ericdriggs.reportcard.model.converter.karate;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
@JsonIgnoreProperties(ignoreUnknown = true)
public class KarateSummary {
    @JsonProperty("elapsedTime")
    private Double elapsedTime;  // milliseconds

    @JsonProperty("totalTime")
    private Double totalTime;

    @JsonProperty("resultDate")
    private String resultDate;  // "2026-01-20 03:00:56 PM"

    @JsonProperty("featuresPassed")
    private Integer featuresPassed;

    @JsonProperty("featuresFailed")
    private Integer featuresFailed;

    @JsonProperty("scenariosPassed")
    private Integer scenariosPassed;

    @JsonProperty("scenariosfailed")  // Note: lowercase 'f' in actual JSON
    private Integer scenariosFailed;

    @JsonProperty("version")
    private String version;
}
```

**KarateConvertersUtil.java** - Static utility enum (follow SurefireConvertersUtil pattern):
```java
package io.github.ericdriggs.reportcard.model.converter.karate;

import io.github.ericdriggs.reportcard.mappers.SharedObjectMappers;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Locale;

@Slf4j
public enum KarateConvertersUtil {
    ;//static methods only

    private static final DateTimeFormatter KARATE_DATE_FORMATTER =
        DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss a", Locale.US);

    public static KarateSummary parseKarateSummary(String jsonContent) {
        if (jsonContent == null || jsonContent.isBlank()) {
            log.warn("Karate summary JSON is null or blank");
            return null;
        }
        return SharedObjectMappers.readValueOrDefault(jsonContent, KarateSummary.class, null);
    }

    public static LocalDateTime parseResultDate(String resultDate) {
        if (resultDate == null || resultDate.isBlank()) {
            log.warn("Karate resultDate is null or blank");
            return null;
        }
        try {
            return LocalDateTime.parse(resultDate, KARATE_DATE_FORMATTER);
        } catch (DateTimeParseException e) {
            log.warn("Failed to parse Karate resultDate: {}", resultDate, e);
            return null;
        }
    }

    public static LocalDateTime calculateStartTime(LocalDateTime endTime, Double elapsedTimeMillis) {
        if (endTime == null) {
            log.warn("Cannot calculate start time: endTime is null");
            return null;
        }
        if (elapsedTimeMillis == null) {
            log.warn("Cannot calculate start time: elapsedTimeMillis is null");
            return null;
        }
        if (elapsedTimeMillis < 0) {
            log.warn("Negative elapsedTimeMillis: {}, treating as null", elapsedTimeMillis);
            return null;
        }

        long elapsedMillisLong = elapsedTimeMillis.longValue();
        return endTime.minusNanos(elapsedMillisLong * 1_000_000);
    }
}
```

Key implementation notes:
- Use `Locale.US` in DateTimeFormatter for consistent AM/PM parsing
- Use `SharedObjectMappers.readValueOrDefault()` which already handles malformed JSON gracefully
- Use lowercase 'hh' for 12-hour format, 'a' for AM/PM marker
- Log warnings at WARN level (not ERROR) per requirements
- Return null on any parse failure (no exceptions propagated)
  </action>
  <verify>
Files compile: `./gradlew :reportcard-model:compileJava`
  </verify>
  <done>
KarateSummary.java exists with @Data, @JsonIgnoreProperties, and fields for elapsedTime, resultDate, etc.
KarateConvertersUtil.java exists with parseKarateSummary(), parseResultDate(), calculateStartTime() methods.
Both classes compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test fixtures and comprehensive unit tests</name>
  <files>
    reportcard-model/src/test/resources/format-samples/karate/karate-summary-valid.json
    reportcard-model/src/test/resources/format-samples/karate/karate-summary-malformed.json
    reportcard-model/src/test/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateConvertersUtilTest.java
  </files>
  <action>
**Create test fixtures directory and files:**

1. Create directory: `reportcard-model/src/test/resources/format-samples/karate/`

2. **karate-summary-valid.json** - Copy from actual Karate output (cucumber-json/karate-reports/karate-summary-json.txt), formatted for readability:
```json
{
  "featureSummary": [],
  "efficiency": 0.22618474365347813,
  "featuresPassed": 5,
  "featuresFailed": 1,
  "totalTime": 348061.0,
  "threads": 5,
  "featuresSkipped": 1882,
  "resultDate": "2026-01-20 03:00:56 PM",
  "scenariosPassed": 6,
  "version": "1.2.0",
  "scenariosfailed": 1,
  "elapsedTime": 307767.0
}
```

3. **karate-summary-malformed.json** - Invalid JSON for error handling test:
```
{invalid json content here
```

**Create unit tests (KarateConvertersUtilTest.java):**

```java
package io.github.ericdriggs.reportcard.model.converter.karate;

import io.github.ericdriggs.reportcard.xml.ResourceReader;
import org.junit.jupiter.api.Test;

import java.time.LocalDateTime;

import static org.junit.jupiter.api.Assertions.*;

public class KarateConvertersUtilTest {

    // === parseKarateSummary tests ===

    @Test
    void parseKarateSummary_validJson_returnsSummary() {
        String karateJson = ResourceReader.resourceAsString("format-samples/karate/karate-summary-valid.json");

        KarateSummary summary = KarateConvertersUtil.parseKarateSummary(karateJson);

        assertNotNull(summary);
        assertEquals(307767.0, summary.getElapsedTime());
        assertEquals("2026-01-20 03:00:56 PM", summary.getResultDate());
        assertEquals(5, summary.getFeaturesPassed());
        assertEquals(1, summary.getFeaturesFailed());
        assertEquals(6, summary.getScenariosPassed());
        assertEquals(1, summary.getScenariosFailed());
        assertEquals("1.2.0", summary.getVersion());
    }

    @Test
    void parseKarateSummary_malformedJson_returnsNull() {
        String malformedJson = ResourceReader.resourceAsString("format-samples/karate/karate-summary-malformed.json");

        KarateSummary summary = KarateConvertersUtil.parseKarateSummary(malformedJson);

        assertNull(summary);
    }

    @Test
    void parseKarateSummary_nullInput_returnsNull() {
        KarateSummary summary = KarateConvertersUtil.parseKarateSummary(null);
        assertNull(summary);
    }

    @Test
    void parseKarateSummary_blankInput_returnsNull() {
        KarateSummary summary = KarateConvertersUtil.parseKarateSummary("   ");
        assertNull(summary);
    }

    @Test
    void parseKarateSummary_emptyJson_returnsSummaryWithNulls() {
        KarateSummary summary = KarateConvertersUtil.parseKarateSummary("{}");

        assertNotNull(summary);
        assertNull(summary.getElapsedTime());
        assertNull(summary.getResultDate());
    }

    // === parseResultDate tests ===

    @Test
    void parseResultDate_validFormat_returnsLocalDateTime() {
        LocalDateTime result = KarateConvertersUtil.parseResultDate("2026-01-20 03:00:56 PM");

        assertNotNull(result);
        assertEquals(2026, result.getYear());
        assertEquals(1, result.getMonthValue());
        assertEquals(20, result.getDayOfMonth());
        assertEquals(15, result.getHour());  // 3 PM = 15:00
        assertEquals(0, result.getMinute());
        assertEquals(56, result.getSecond());
    }

    @Test
    void parseResultDate_amTime_returnsCorrectHour() {
        LocalDateTime result = KarateConvertersUtil.parseResultDate("2026-01-20 09:30:00 AM");

        assertNotNull(result);
        assertEquals(9, result.getHour());
    }

    @Test
    void parseResultDate_noon_returnsCorrectHour() {
        LocalDateTime result = KarateConvertersUtil.parseResultDate("2026-01-20 12:00:00 PM");

        assertNotNull(result);
        assertEquals(12, result.getHour());
    }

    @Test
    void parseResultDate_midnight_returnsCorrectHour() {
        LocalDateTime result = KarateConvertersUtil.parseResultDate("2026-01-20 12:00:00 AM");

        assertNotNull(result);
        assertEquals(0, result.getHour());
    }

    @Test
    void parseResultDate_invalidFormat_returnsNull() {
        LocalDateTime result = KarateConvertersUtil.parseResultDate("2026/01/20 15:00:56");
        assertNull(result);
    }

    @Test
    void parseResultDate_nullInput_returnsNull() {
        LocalDateTime result = KarateConvertersUtil.parseResultDate(null);
        assertNull(result);
    }

    @Test
    void parseResultDate_blankInput_returnsNull() {
        LocalDateTime result = KarateConvertersUtil.parseResultDate("  ");
        assertNull(result);
    }

    // === calculateStartTime tests ===

    @Test
    void calculateStartTime_validInputs_returnsCorrectStartTime() {
        LocalDateTime endTime = LocalDateTime.of(2026, 1, 20, 15, 0, 56);
        Double elapsedMillis = 307767.0;  // ~5 minutes 7 seconds

        LocalDateTime startTime = KarateConvertersUtil.calculateStartTime(endTime, elapsedMillis);

        assertNotNull(startTime);
        // 15:00:56 - 307.767 seconds = 14:55:48.233
        assertEquals(2026, startTime.getYear());
        assertEquals(1, startTime.getMonthValue());
        assertEquals(20, startTime.getDayOfMonth());
        assertEquals(14, startTime.getHour());
        assertEquals(55, startTime.getMinute());
        assertEquals(48, startTime.getSecond());
    }

    @Test
    void calculateStartTime_nullEndTime_returnsNull() {
        LocalDateTime result = KarateConvertersUtil.calculateStartTime(null, 1000.0);
        assertNull(result);
    }

    @Test
    void calculateStartTime_nullElapsedTime_returnsNull() {
        LocalDateTime endTime = LocalDateTime.of(2026, 1, 20, 15, 0, 0);
        LocalDateTime result = KarateConvertersUtil.calculateStartTime(endTime, null);
        assertNull(result);
    }

    @Test
    void calculateStartTime_negativeElapsedTime_returnsNull() {
        LocalDateTime endTime = LocalDateTime.of(2026, 1, 20, 15, 0, 0);
        LocalDateTime result = KarateConvertersUtil.calculateStartTime(endTime, -1000.0);
        assertNull(result);
    }

    @Test
    void calculateStartTime_zeroElapsedTime_returnsEndTime() {
        LocalDateTime endTime = LocalDateTime.of(2026, 1, 20, 15, 0, 0);
        LocalDateTime result = KarateConvertersUtil.calculateStartTime(endTime, 0.0);

        assertNotNull(result);
        assertEquals(endTime, result);
    }

    @Test
    void calculateStartTime_veryLargeElapsedTime_acceptsAsIs() {
        LocalDateTime endTime = LocalDateTime.of(2026, 1, 20, 15, 0, 0);
        Double twentyFiveHoursInMillis = 25.0 * 60 * 60 * 1000;  // > 24 hours

        LocalDateTime result = KarateConvertersUtil.calculateStartTime(endTime, twentyFiveHoursInMillis);

        assertNotNull(result);
        // Should be previous day, 14:00
        assertEquals(19, result.getDayOfMonth());
        assertEquals(14, result.getHour());
    }

    // === Integration test: full parsing flow ===

    @Test
    void fullParsingFlow_validSummary_extractsTimingCorrectly() {
        String karateJson = ResourceReader.resourceAsString("format-samples/karate/karate-summary-valid.json");

        KarateSummary summary = KarateConvertersUtil.parseKarateSummary(karateJson);
        assertNotNull(summary);

        LocalDateTime endTime = KarateConvertersUtil.parseResultDate(summary.getResultDate());
        assertNotNull(endTime);

        LocalDateTime startTime = KarateConvertersUtil.calculateStartTime(endTime, summary.getElapsedTime());
        assertNotNull(startTime);

        // Verify start is before end
        assertTrue(startTime.isBefore(endTime));
    }
}
```

Test coverage:
- PARS-01: parseKarateSummary parses valid JSON
- PARS-02: elapsedTime extracted correctly (307767.0)
- PARS-03: resultDate extracted correctly ("2026-01-20 03:00:56 PM")
- PARS-04: calculateStartTime computes start = end - elapsed
- PARS-05: Malformed JSON, null inputs, invalid dates all return null (no exceptions)
  </action>
  <verify>
All tests pass: `./gradlew :reportcard-model:test --tests "io.github.ericdriggs.reportcard.model.converter.karate.KarateConvertersUtilTest"`
  </verify>
  <done>
Test fixtures exist in format-samples/karate/ directory.
KarateConvertersUtilTest.java exists with tests for:
- Valid JSON parsing
- Malformed JSON handling (returns null)
- Date parsing (AM/PM, noon, midnight edge cases)
- Start time calculation (valid, null inputs, negative elapsed)
- Full integration flow
All tests pass.
  </done>
</task>

</tasks>

<verification>
Run full test suite for reportcard-model module:
```bash
./gradlew :reportcard-model:test
```

Verify no regressions in existing tests.
</verification>

<success_criteria>
1. KarateSummary.java compiles and deserializes Karate JSON
2. KarateConvertersUtil.java provides three static methods: parseKarateSummary, parseResultDate, calculateStartTime
3. All methods return null (not exceptions) on invalid input
4. Unit tests cover all requirements (PARS-01 through PARS-05)
5. All existing reportcard-model tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-karate-parser/02-01-SUMMARY.md`
</output>
