---
phase: 06-reportcard-client-java-support
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - /Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java/src/main/java/io/github/ericdriggs/reportcard/JunitHtmlPostRequest.java
  - /Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java/src/main/java/io/github/ericdriggs/reportcard/compress/FileExtensionPathPredicates.java
  - /Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java/build.gradle
  - /Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java/src/test/java/io/github/ericdriggs/reportcard/ReportcardClientWireMockTest.java
autonomous: true

must_haves:
  truths:
    - "Client accepts optional karateFolderPath in builder"
    - "Client sends 3 multipart files when karate provided"
    - "Client sends 2 multipart files when karate omitted (backwards compatible)"
    - "Mock tests verify multipart request structure without real server"
  artifacts:
    - path: "/Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java/src/main/java/io/github/ericdriggs/reportcard/JunitHtmlPostRequest.java"
      provides: "Optional karateFolderPath field and conditional multipart logic"
      contains: "Path karateFolderPath"
    - path: "/Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java/src/main/java/io/github/ericdriggs/reportcard/compress/FileExtensionPathPredicates.java"
      provides: "JSON file filter predicate"
      contains: "Predicate<Path> JSON"
    - path: "/Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java/src/test/java/io/github/ericdriggs/reportcard/ReportcardClientWireMockTest.java"
      provides: "Mock tests for with/without Karate scenarios"
      min_lines: 80
  key_links:
    - from: "JunitHtmlPostRequest.getMultipartFiles()"
      to: "multipartFile(karateFolderPath, karateFileName, FileExtensionPathPredicates.JSON)"
      via: "conditional karate.tar.gz creation"
      pattern: "if.*karateFolderPath.*!=.*null"
    - from: "ReportcardClientWireMockTest"
      to: "@WireMockTest"
      via: "JUnit 5 integration"
      pattern: "@WireMockTest"
    - from: "Mock stub"
      to: "withMultipartRequestBody.*karate.tar.gz"
      via: "multipart verification"
      pattern: "withMultipartRequestBody.*aMultipart.*karate"
---

<objective>
Add optional Karate JSON upload support to the external reportcard-client-java library with WireMock-based mock testing.

**Purpose:** Enable external client users to upload Karate JSON alongside JUnit XML, mirroring Phase 4's in-tree client implementation but adapted to the external repository's architecture.

**Output:** External client library with optional karateFolderPath parameter, JSON file filtering, and comprehensive mock tests verifying multipart request structure without requiring a real server.
</objective>

<execution_context>
@/Users/eric.r.driggs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eric.r.driggs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/eric.r.driggs/github/ericdriggs/reportcard-cucumber-json/.planning/PROJECT.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard-cucumber-json/.planning/ROADMAP.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard-cucumber-json/.planning/STATE.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard-cucumber-json/.planning/phases/06-reportcard-client-java-support/06-CONTEXT.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard-cucumber-json/.planning/phases/06-reportcard-client-java-support/06-RESEARCH.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard-cucumber-json/.planning/phases/04-client-library/04-01-SUMMARY.md

## Repository Location

**IMPORTANT:** This phase works in a completely separate codebase:
- **External repo:** `/Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java`
- **This repo:** `/Users/eric.r.driggs/github/ericdriggs/reportcard-cucumber-json`
- No shared code between repositories
- Independent versioning and CI/CD

All file paths and operations target the external repository at `/Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java/`.

## Key Differences from Phase 4

Phase 4 implemented Karate support in the **in-tree** `reportcard-client` module (Gradle submodule of this repo).
Phase 6 implements the same functionality in the **external** `reportcard-client-java` repository (separate repo, separate CI, published to Hulu artifactory).

**Architectural differences:**
- External client uses commons-http-client (internal Hulu library) vs in-tree uses WebClient
- External client uses TarCompressor utility vs in-tree uses TarGzUtil
- External client has Apache Commons Compress 1.28.0 vs in-tree has 1.26.0
- External client has existing integration tests hitting real servers
- External client needs WireMock 3.x added as new dependency

**Pattern similarities:**
- Optional karateFolderPath field in builder
- Conditional multipart file inclusion
- JSON file filtering via predicate
- Backwards compatibility via optional parameter
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add optional Karate support to JunitHtmlPostRequest</name>
  <files>
    /Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java/src/main/java/io/github/ericdriggs/reportcard/JunitHtmlPostRequest.java
    /Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java/src/main/java/io/github/ericdriggs/reportcard/compress/FileExtensionPathPredicates.java
  </files>
  <action>
**JunitHtmlPostRequest.java changes:**

1. Add optional field to @Builder class:
   ```java
   Path karateFolderPath;  // Optional - null if not provided
   ```

2. Add constant for multipart filename:
   ```java
   final static String karateFileName = "karate.tar.gz";
   ```

3. Update getMultipartFiles() method to conditionally include karate:
   ```java
   @JsonIgnore
   public List<MultipartFile> getMultipartFiles() {
       if (htmlFolderPath == null) {
           throw new NullPointerException("htmlFolderPath");
       }
       if (junitFolderPath == null) {
           throw new NullPointerException("junitFolderPath");
       }

       List<MultipartFile> files = new ArrayList<>();
       files.add(multipartFile(junitFolderPath, junitFileName, FileExtensionPathPredicates.XML));
       files.add(multipartFile(htmlFolderPath, htmlFileName, FileExtensionPathPredicates.ALL_FILES));

       // NEW: Add karate.tar.gz if provided
       if (karateFolderPath != null) {
           files.add(multipartFile(karateFolderPath, karateFileName, FileExtensionPathPredicates.JSON));
       }

       return files;
   }
   ```

4. DO NOT add validation for karateFolderPath in validate() method - it must remain optional for backwards compatibility.

**FileExtensionPathPredicates.java changes:**

Add JSON file filter following existing pattern:
```java
public static final Predicate<Path> JSON = hasExtension(".json");
```

**Why this approach:**
- Matches Phase 4 in-tree client pattern exactly
- Lombok @Builder automatically handles optional fields
- Conditional inclusion preserves backwards compatibility
- TarCompressor utility already supports predicate filtering
- No changes needed to ReportcardClient or ReportcardMetadata classes
  </action>
  <verify>
Build the external client:
```bash
cd /Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java
./gradlew clean build
```

Build must succeed (compilation proves API changes are valid).
  </verify>
  <done>
- JunitHtmlPostRequest has karateFolderPath field and karateFileName constant
- getMultipartFiles() conditionally adds karate.tar.gz when karateFolderPath is not null
- FileExtensionPathPredicates has JSON predicate
- Code compiles successfully
- No changes to validation (karate remains optional)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add WireMock dependency for mock testing</name>
  <files>
    /Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java/build.gradle
  </files>
  <action>
Add WireMock 3.3.1 to testImplementation dependencies in build.gradle:

```gradle
dependencies {
    // ... existing dependencies ...

    // Testing
    testImplementation "org.junit.jupiter:junit-jupiter-api:5.8.1"
    testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:5.8.1"
    testImplementation "org.junit-pioneer:junit-pioneer:1.9.1"
    testImplementation "org.wiremock:wiremock:3.3.1"  // NEW: Mock HTTP server for testing
}
```

**Why WireMock 3.3.1:**
- Native JUnit 5 support via @WireMockTest annotation (no manual lifecycle)
- Excellent multipart request matching and verification
- Dynamic port allocation prevents test conflicts
- Standard choice for HTTP client mock testing
- Research verified this version works well with JUnit 5.8.1

**DO NOT:**
- Add to implementation or compileOnly (test-only dependency)
- Use WireMock 2.x (lacks JUnit 5 native support)
- Use MockWebServer (WireMock has better multipart handling)
  </action>
  <verify>
Verify dependency resolution:
```bash
cd /Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java
./gradlew dependencies --configuration testImplementation | grep wiremock
```

Should show `org.wiremock:wiremock:3.3.1` in dependency tree.
  </verify>
  <done>
- WireMock 3.3.1 added to testImplementation dependencies
- Gradle resolves dependency successfully
- No conflicts with existing test dependencies
  </done>
</task>

<task type="auto">
  <name>Task 3: Create WireMock tests for Karate upload scenarios</name>
  <files>
    /Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java/src/test/java/io/github/ericdriggs/reportcard/ReportcardClientWireMockTest.java
  </files>
  <action>
Create new test class ReportcardClientWireMockTest.java using WireMock 3.x @WireMockTest annotation.

**Test scenarios to implement:**

1. **postJunitHtml_withKarate_success** - Verify client sends 3 multipart files when karate provided
   - Stub POST to `/v1/api/junit/storage/.*/tar.gz` expecting 3 parts
   - Build request with all three paths (junit, html, karate)
   - Verify response 201 and all three parts sent

2. **postJunitHtml_withoutKarate_backwardsCompatible** - Verify client sends 2 multipart files when karate omitted
   - Stub POST expecting only 2 parts (junit, storage)
   - Build request WITHOUT karateFolderPath
   - Verify response 201 and only 2 parts sent
   - This proves backwards compatibility

**Follow these patterns from research:**
```java
@WireMockTest
public class ReportcardClientWireMockTest {

    @TempDir
    Path tempDir;

    @Test
    void postJunitHtml_withKarate_success(WireMockRuntimeInfo wmRuntimeInfo) throws IOException {
        // Create temp directories with test files
        Path junitDir = createTempFiles(tempDir.resolve("junit"), "test-result.xml");
        Path htmlDir = createTempFiles(tempDir.resolve("html"), "index.html");
        Path karateDir = createTempFiles(tempDir.resolve("karate"), "karate-summary.json");

        // Stub server response expecting 3 parts
        stubFor(post(urlPathMatching("/v1/api/junit/storage/.*/tar.gz"))
            .withMultipartRequestBody(aMultipart().withName("junit.tar.gz"))
            .withMultipartRequestBody(aMultipart().withName("storage.tar.gz"))
            .withMultipartRequestBody(aMultipart().withName("karate.tar.gz"))
            .willReturn(aResponse()
                .withStatus(201)
                .withBody("{\"responseDetails\":{\"httpStatus\":201},\"success\":true}")));

        // Build request with karate
        ReportcardMetadata metadata = ReportcardMetadata.builder()
            .company("test-company")
            .org("test-org")
            .repo("test-repo")
            .branch("main")
            .sha("abc123")
            .stage("test")
            .jobInfo(Map.of())
            .build();

        JunitHtmlPostRequest request = JunitHtmlPostRequest.builder()
            .reportcardServerUrl(wmRuntimeInfo.getHttpBaseUrl())
            .reportCardMetadata(metadata)
            .htmlFolderPath(htmlDir)
            .junitFolderPath(junitDir)
            .karateFolderPath(karateDir)  // With karate
            .build();

        ReportcardClient client = ReportcardClient.builder().build();
        JunitHtmlPostResponse response = client.postJunitHtml(request);

        assertTrue(response.isSuccess());
        assertEquals(201, response.getResponseDetails().getHttpStatus());

        // Verify all 3 parts sent
        verify(postRequestedFor(urlPathMatching("/v1/api/junit/storage/.*/tar.gz"))
            .withAnyRequestBodyPart(aMultipart().withName("junit.tar.gz"))
            .withAnyRequestBodyPart(aMultipart().withName("storage.tar.gz"))
            .withAnyRequestBodyPart(aMultipart().withName("karate.tar.gz")));
    }

    @Test
    void postJunitHtml_withoutKarate_backwardsCompatible(WireMockRuntimeInfo wmRuntimeInfo) throws IOException {
        // Same pattern but WITHOUT karateFolderPath
        // Stub expects only 2 parts
        // Verify only 2 parts sent
    }

    private Path createTempFiles(Path dir, String... fileNames) throws IOException {
        Files.createDirectories(dir);
        for (String fileName : fileNames) {
            Files.writeString(dir.resolve(fileName), "test content");
        }
        return dir;
    }
}
```

**Important imports:**
```java
import com.github.tomakehurst.wiremock.junit5.WireMockRuntimeInfo;
import com.github.tomakehurst.wiremock.junit5.WireMockTest;
import static com.github.tomakehurst.wiremock.client.WireMock.*;
```

**Why these tests matter:**
- Mock tests don't require real server (faster, no network dependencies)
- Verify multipart structure without hitting actual reportcard server
- Test both with-karate and without-karate paths explicitly
- Backwards compatibility proven by without-karate test passing
  </action>
  <verify>
Run the new WireMock tests:
```bash
cd /Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java
./gradlew test --tests "io.github.ericdriggs.reportcard.ReportcardClientWireMockTest"
```

Both tests must pass:
- postJunitHtml_withKarate_success
- postJunitHtml_withoutKarate_backwardsCompatible
  </verify>
  <done>
- ReportcardClientWireMockTest.java created with @WireMockTest
- Test with karate passes (3 multipart files verified)
- Test without karate passes (2 multipart files verified, proves backwards compatibility)
- Tests use @TempDir for file creation
- Tests verify multipart structure via WireMock's aMultipart() matchers
  </done>
</task>

</tasks>

<verification>
## Overall Phase Checks

After all tasks complete, verify the complete integration:

**Build verification:**
```bash
cd /Users/eric.r.driggs/git/hulu/sublife/reportcard-client-java
./gradlew clean build
```

All tests must pass (new WireMock tests + existing integration tests).

**API backwards compatibility:**
Existing code using JunitHtmlPostRequest.builder() without karate still compiles and works:
```java
// Legacy usage (no karate) - must still work
JunitHtmlPostRequest request = JunitHtmlPostRequest.builder()
    .reportcardServerUrl(url)
    .reportCardMetadata(metadata)
    .htmlFolderPath(htmlPath)
    .junitFolderPath(junitPath)
    .build();
```

**New API with karate:**
New code can optionally include karate:
```java
// New usage (with karate) - new capability
JunitHtmlPostRequest request = JunitHtmlPostRequest.builder()
    .reportcardServerUrl(url)
    .reportCardMetadata(metadata)
    .htmlFolderPath(htmlPath)
    .junitFolderPath(junitPath)
    .karateFolderPath(karatePath)  // Optional
    .build();
```

**Test coverage:**
- WireMock tests verify multipart structure (with/without karate)
- Existing integration tests continue to pass (backwards compatibility)
- Both paths exercised in CI

**Files created/modified:**
- JunitHtmlPostRequest.java - optional karateFolderPath field, conditional multipart logic
- FileExtensionPathPredicates.java - JSON predicate
- build.gradle - WireMock dependency
- ReportcardClientWireMockTest.java - mock tests
</verification>

<success_criteria>
Phase 6 complete when:

1. **Client API accepts optional Karate parameter** - JunitHtmlPostRequest.builder() has karateFolderPath field
2. **Client conditionally includes karate.tar.gz** - getMultipartFiles() returns 2 or 3 files based on parameter
3. **JSON file filtering works** - FileExtensionPathPredicates.JSON filters .json files for tar.gz creation
4. **WireMock tests pass** - Mock tests verify multipart structure without real server
5. **Backwards compatibility proven** - Test without karate passes, existing integration tests pass
6. **Build succeeds** - `./gradlew clean build` passes all tests

**Observable behaviors:**
- Existing client code (no karate) compiles and runs unchanged
- New client code (with karate) sends 3 multipart files to server
- Mock tests verify request structure deterministically
- No server dependency for unit testing multipart logic
</success_criteria>

<output>
After completion, create `.planning/phases/06-reportcard-client-java-support/06-01-SUMMARY.md` using the summary template.

**Summary should capture:**
- Mirrored Phase 4 pattern but for external repository
- WireMock 3.x integration for robust mock testing
- Backwards compatibility proven via explicit test
- Key difference: external repo uses commons-http-client vs in-tree uses WebClient
</output>
