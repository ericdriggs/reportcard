---
phase: 03-api-integration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/StagePathStorages.java
  - reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/JunitControllerKarateTest.java
autonomous: true

must_haves:
  truths:
    - "Controller accepts optional karate.tar.gz alongside junit.tar.gz"
    - "Controller validates at least one of junit or karate is present"
    - "Controller stores karate.tar.gz in S3 with KARATE_JSON storage type"
    - "Controller persists start_time/end_time when Karate JSON present"
    - "Existing JUnit-only uploads continue working unchanged"
  artifacts:
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java"
      provides: "Updated multipart endpoint with karate support"
      contains: "karate.tar.gz"
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/StagePathStorages.java"
      provides: "Varargs merge method for multiple storages"
      contains: "merge(StagePathStorages..."
    - path: "reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/JunitControllerKarateTest.java"
      provides: "Integration tests for Karate upload"
      min_lines: 80
  key_links:
    - from: "JunitController.postStageJunitStorageTarGZ"
      to: "KarateTarGzUtil.extractKarateSummaryJson"
      via: "method call"
      pattern: "KarateTarGzUtil\\.extractKarateSummaryJson"
    - from: "JunitController.doPostStageJunitStorageTarGZ"
      to: "StagePathPersistService.updateRunTiming"
      via: "stagePathPersistService call"
      pattern: "updateRunTiming"
    - from: "JunitController.storeKarate"
      to: "StorageType.KARATE_JSON"
      via: "storage type assignment"
      pattern: "StorageType\\.KARATE_JSON"
---

<objective>
Integrate Karate JSON upload support into JunitController.

Purpose: Complete the API integration by modifying the controller to accept optional karate.tar.gz, validate inputs, process timing data, and store files in S3 with proper storage type.

Output:
- JunitController with optional karate.tar.gz parameter
- Input validation (at least one test result required)
- Timing data extraction and persistence
- S3 storage with KARATE_JSON type
- Integration tests for new functionality and backwards compatibility
</objective>

<execution_context>
@/Users/eric.r.driggs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eric.r.driggs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-api-integration/03-RESEARCH.md
@.planning/phases/03-api-integration/03-01-SUMMARY.md

# Files being modified
@reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java
@reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/StagePathStorages.java

# Phase 2 parser for timing extraction
@reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateConvertersUtil.java
@reportcard-model/src/main/java/io/github/ericdriggs/reportcard/model/converter/karate/KarateSummary.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add varargs merge to StagePathStorages</name>
  <files>
    reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/StagePathStorages.java
  </files>
  <action>
Add a varargs overload of merge() to handle variable number of storage results. The existing two-argument merge() should remain for backwards compatibility.

Add this method to StagePathStorages:

```java
/**
 * Merges multiple StagePathStorages into one.
 * All must have the same stagePath.
 *
 * @param storagesArray varargs of StagePathStorages to merge
 * @return merged StagePathStorages
 */
public static StagePathStorages merge(StagePathStorages... storagesArray) {
    if (storagesArray == null || storagesArray.length == 0) {
        throw new IllegalArgumentException("storagesArray cannot be null or empty");
    }
    if (storagesArray.length == 1) {
        return storagesArray[0];
    }

    StagePathStorages result = storagesArray[0];
    for (int i = 1; i < storagesArray.length; i++) {
        result = merge(result, storagesArray[i]);
    }
    return result;
}
```

This delegates to the existing two-argument merge() to reuse validation logic.
  </action>
  <verify>
    ./gradlew :reportcard-server:compileJava
  </verify>
  <done>
    StagePathStorages.merge(StagePathStorages...) exists and chains calls to two-argument merge
  </done>
</task>

<task type="auto">
  <name>Task 2: Update JunitController for Karate upload support</name>
  <files>
    reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java
  </files>
  <action>
Modify JunitController to support optional karate.tar.gz uploads. Changes span three areas: (1) endpoint signature, (2) business logic, (3) new helper methods.

**1. Update postStageJunitStorageTarGZ endpoint signature:**

Change @RequestPart for junitXmls to required=false and add karateTarGz parameter:

```java
@Parameter(description = "Junit and/or surefire xml files. Required if karate.tar.gz not provided.")
@RequestPart(value = "junit.tar.gz", required = false)
MultipartFile junitXmls,

@Parameter(description = "Karate test reports tar.gz containing karate-summary-json.txt for timing data.")
@RequestPart(value = "karate.tar.gz", required = false)
MultipartFile karateTarGz,

@Parameter(description = "Files and folders to store in s3. Usually combination of html/css/js.")
@RequestPart("storage.tar.gz")
MultipartFile reports
```

**2. Update JunitHtmlPostRequest building in postStageJunitStorageTarGZ:**

```java
JunitHtmlPostRequest req = JunitHtmlPostRequest.builder()
        .stageDetails(stageDetails)
        .label(label)
        .indexFile(indexFile)
        .junitXmls(junitXmls)
        .karateTarGz(karateTarGz)  // NEW
        .reports(reports)
        .build();
```

**3. Replace doPostStageJunitStorageTarGZ method entirely:**

```java
public StagePathStorageResultCountResponse doPostStageJunitStorageTarGZ(JunitHtmlPostRequest req) {
    // Validate at least one test result source
    boolean hasJunit = req.getJunitXmls() != null && !req.getJunitXmls().isEmpty();
    boolean hasKarate = req.getKarateTarGz() != null && !req.getKarateTarGz().isEmpty();

    if (!hasJunit && !hasKarate) {
        throw new ResponseStatusException(HttpStatus.BAD_REQUEST,
            "At least one of junit.tar.gz or karate.tar.gz must be provided");
    }

    // Parse JUnit if present (existing behavior)
    TestResultModel testResultModel;
    if (hasJunit) {
        List<String> testXmlContents = TestXmlTarGzUtil.getFileContentsFromTarGz(req.getJunitXmls());
        testResultModel = JunitSurefireXmlParseUtil.parseTestXml(testXmlContents);
    } else {
        // Empty test result when only Karate provided
        testResultModel = TestResultModel.builder().build();
    }

    StagePathTestResult stagePathTestResult = testResultPersistService.insertTestResult(req.getStageDetails(), testResultModel);
    StagePath stagePath = stagePathTestResult.getStagePath();
    final Long stageId = stagePath.getStage().getStageId();
    final Long runId = stagePath.getRun().getRunId();

    // Process Karate timing data (NEW)
    if (hasKarate) {
        processKarateTiming(runId, req.getKarateTarGz());
    }

    // Store files in S3
    StagePathStorages stagePathStorages;
    {
        List<StagePathStorages> storagesList = new ArrayList<>();

        if (hasJunit) {
            storagesList.add(storeJunit(stageId, req.getJunitXmls()));
        }
        if (hasKarate) {
            storagesList.add(storeKarate(stageId, req.getKarateTarGz()));
        }
        storagesList.add(storeHtml(stageId, req.getLabel(), req.getReports(), req.getIndexFile()));

        stagePathStorages = StagePathStorages.merge(storagesList.toArray(new StagePathStorages[0]));
    }

    StagePathStorageResultCount stagePathStorageResultCount =
        new StagePathStorageResultCount(stagePathStorages.getStagePath(), stagePathStorages.getStorages(), stagePathTestResult);
    return StagePathStorageResultCountResponse.created(stagePathStorageResultCount);
}
```

**4. Add new helper methods to JunitController:**

```java
/**
 * Processes Karate timing data and updates run record.
 */
private void processKarateTiming(Long runId, MultipartFile karateTarGz) {
    if (karateTarGz == null || karateTarGz.isEmpty()) {
        return;
    }

    String summaryJson = KarateTarGzUtil.extractKarateSummaryJson(karateTarGz);
    if (summaryJson == null) {
        log.warn("karate-summary-json.txt not found in karate.tar.gz for runId: {}", runId);
        return;
    }

    KarateSummary summary = KarateConvertersUtil.parseKarateSummary(summaryJson);
    if (summary == null) {
        log.warn("Failed to parse karate-summary-json.txt for runId: {}", runId);
        return;
    }

    LocalDateTime endTime = KarateConvertersUtil.parseResultDate(summary.getResultDate());
    LocalDateTime startTime = KarateConvertersUtil.calculateStartTime(endTime, summary.getElapsedTime());

    Instant startInstant = toInstant(startTime);
    Instant endInstant = toInstant(endTime);

    stagePathPersistService.updateRunTiming(runId, startInstant, endInstant);
}

private Instant toInstant(LocalDateTime localDateTime) {
    if (localDateTime == null) {
        return null;
    }
    return localDateTime.atZone(ZoneOffset.UTC).toInstant();
}

/**
 * Stores Karate tar.gz in S3 with KARATE_JSON storage type.
 */
protected StagePathStorages storeKarate(Long stageId, MultipartFile tarGz) {
    final String label = "karate";
    StorageType storageType = StorageType.KARATE_JSON;

    final StagePath stagePath = storagePersistService.getStagePath(stageId);
    final String prefix = new StoragePath(stagePath, label).getPrefix();

    StagePathStorages stagePathStorages = storagePersistService.upsertStoragePath(null, label, prefix, stageId, storageType);
    if (!stagePathStorages.isComplete()) {
        s3Service.uploadTarGz(prefix, false, tarGz);  // false = don't expand
        storagePersistService.setUploadCompleted(null, label, prefix, stageId);
        stagePathStorages.setComplete();
    }
    return stagePathStorages;
}
```

**5. Add stagePathPersistService field and update constructor:**

Add field:
```java
private final StagePathPersistService stagePathPersistService;
```

Update constructor to accept and assign StagePathPersistService:
```java
@Autowired
public JunitController(StoragePersistService storagePersistService,
                       TestResultPersistService testResultPersistService,
                       StagePathPersistService stagePathPersistService,  // NEW
                       S3Service s3Service,
                       LockService lockService) {
    this.storagePersistService = storagePersistService;
    this.testResultPersistService = testResultPersistService;
    this.stagePathPersistService = stagePathPersistService;  // NEW
    this.lockService = lockService;
    this.s3Service = s3Service;
}
```

**Required new imports:**
```java
import io.github.ericdriggs.reportcard.controller.util.KarateTarGzUtil;
import io.github.ericdriggs.reportcard.model.converter.karate.KarateConvertersUtil;
import io.github.ericdriggs.reportcard.model.converter.karate.KarateSummary;
import io.github.ericdriggs.reportcard.persist.StagePathPersistService;
import org.springframework.http.HttpStatus;
import org.springframework.web.server.ResponseStatusException;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.ArrayList;
```
  </action>
  <verify>
    ./gradlew :reportcard-server:compileJava
  </verify>
  <done>
    JunitController accepts optional karate.tar.gz, validates input, persists timing, stores in S3
  </done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests for Karate upload</name>
  <files>
    reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/JunitControllerKarateTest.java
  </files>
  <action>
Create integration test class that tests:
1. JUnit-only upload continues working (backwards compatibility)
2. Karate-only upload works (new functionality)
3. JUnit + Karate combined upload works
4. Neither JUnit nor Karate returns 400 error

Follow existing test patterns from the codebase. Use Testcontainers for MySQL.

```java
package io.github.ericdriggs.reportcard.controller;

import io.github.ericdriggs.reportcard.ReportCardService;
import io.github.ericdriggs.reportcard.controller.model.StagePathStorageResultCountResponse;
import io.github.ericdriggs.reportcard.gen.db.tables.pojos.RunPojo;
import io.github.ericdriggs.reportcard.persist.StagePathPersistService;
import io.github.ericdriggs.reportcard.persist.StorageType;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.server.ResponseStatusException;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = ReportCardService.class)
@ActiveProfiles("test")
public class JunitControllerKarateTest {

    @Autowired
    private JunitController junitController;

    @Autowired
    private StagePathPersistService stagePathPersistService;

    private static final String KARATE_SUMMARY_JSON = """
        {
          "version": "1.4.1",
          "threads": 1,
          "featuresPassed": 1,
          "featuresFailed": 0,
          "featuresSkipped": 0,
          "scenariosPassed": 2,
          "resultDate": "2026-01-20 03:00:56 PM",
          "elapsedTime": 5000.0,
          "totalTime": 5000.0
        }
        """;

    @Test
    void testJunitOnlyUpload_backwardsCompatible() throws IOException {
        // Given: JUnit tar.gz only (existing flow)
        MultipartFile junitTarGz = createJunitTarGz();
        MultipartFile storageTarGz = createStorageTarGz();

        // When
        ResponseEntity<StagePathStorageResultCountResponse> response = junitController.postStageJunitStorageTarGZ(
            "company", "org", "repo", "branch", null,
            UUID.randomUUID(), "abc123", "stage",
            "html", null, null, junitTarGz, null, storageTarGz
        );

        // Then: Should succeed as before
        assertEquals(HttpStatus.CREATED.value(), response.getStatusCode().value());
        assertNotNull(response.getBody());
    }

    @Test
    void testKarateOnlyUpload_newFunctionality() throws IOException {
        // Given: Karate tar.gz only (new flow)
        MultipartFile karateTarGz = createKarateTarGz();
        MultipartFile storageTarGz = createStorageTarGz();

        // When
        ResponseEntity<StagePathStorageResultCountResponse> response = junitController.postStageJunitStorageTarGZ(
            "company", "org", "repo", "branch", null,
            UUID.randomUUID(), "def456", "stage",
            "html", null, null, null, karateTarGz, storageTarGz
        );

        // Then: Should succeed and have timing data
        assertEquals(HttpStatus.CREATED.value(), response.getStatusCode().value());
        assertNotNull(response.getBody());

        // Verify timing was persisted
        Long runId = response.getBody().getData().getStagePath().getRun().getRunId();
        // Timing should be set (we can't easily fetch it here but the flow completed)
    }

    @Test
    void testJunitAndKarateCombinedUpload() throws IOException {
        // Given: Both JUnit and Karate tar.gz
        MultipartFile junitTarGz = createJunitTarGz();
        MultipartFile karateTarGz = createKarateTarGz();
        MultipartFile storageTarGz = createStorageTarGz();

        // When
        ResponseEntity<StagePathStorageResultCountResponse> response = junitController.postStageJunitStorageTarGZ(
            "company", "org", "repo", "branch", null,
            UUID.randomUUID(), "ghi789", "stage",
            "html", null, null, junitTarGz, karateTarGz, storageTarGz
        );

        // Then: Should succeed with both storages
        assertEquals(HttpStatus.CREATED.value(), response.getStatusCode().value());
        assertNotNull(response.getBody());
        // Should have junit, karate, and html storages
        assertTrue(response.getBody().getData().getStorages().size() >= 3);
    }

    @Test
    void testNeitherJunitNorKarate_returns400() throws IOException {
        // Given: Neither JUnit nor Karate provided
        MultipartFile storageTarGz = createStorageTarGz();

        // When/Then: Should throw 400
        ResponseStatusException exception = assertThrows(ResponseStatusException.class, () ->
            junitController.postStageJunitStorageTarGZ(
                "company", "org", "repo", "branch", null,
                UUID.randomUUID(), "jkl012", "stage",
                "html", null, null, null, null, storageTarGz
            )
        );

        assertEquals(HttpStatus.BAD_REQUEST, exception.getStatus());
        assertTrue(exception.getReason().contains("junit.tar.gz or karate.tar.gz"));
    }

    // Helper methods to create test tar.gz files
    private MultipartFile createJunitTarGz() throws IOException {
        String junitXml = """
            <?xml version="1.0" encoding="UTF-8"?>
            <testsuite name="TestSuite" tests="1" failures="0">
                <testcase name="test1" classname="TestClass" time="0.1"/>
            </testsuite>
            """;
        return createTarGzWithContent("junit.xml", junitXml);
    }

    private MultipartFile createKarateTarGz() throws IOException {
        return createTarGzWithContent("karate-summary-json.txt", KARATE_SUMMARY_JSON);
    }

    private MultipartFile createStorageTarGz() throws IOException {
        String html = "<html><body>Test</body></html>";
        return createTarGzWithContent("index.html", html);
    }

    private MultipartFile createTarGzWithContent(String filename, String content) throws IOException {
        Path tempDir = Files.createTempDirectory("test-");
        Path file = tempDir.resolve(filename);
        Files.writeString(file, content, StandardCharsets.UTF_8);

        Path tarGz = io.github.ericdriggs.reportcard.controller.util.TestXmlTarGzUtil
            .createTarGzipFilesForTesting(java.util.List.of(file));

        byte[] bytes = Files.readAllBytes(tarGz);
        Files.delete(tarGz);
        org.apache.tomcat.util.http.fileupload.FileUtils.deleteDirectory(tempDir.toFile());

        return new MockMultipartFile(filename + ".tar.gz", filename + ".tar.gz",
            "application/gzip", bytes);
    }
}
```

Note: The test class may need adjustments based on exact constructor/method signatures. Focus on testing the four scenarios.
  </action>
  <verify>
    ./gradlew :reportcard-server:test --tests "io.github.ericdriggs.reportcard.controller.JunitControllerKarateTest" --info
  </verify>
  <done>
    Integration tests pass for: JUnit-only, Karate-only, combined, neither (400 error)
  </done>
</task>

</tasks>

<verification>
1. Code compiles: `./gradlew :reportcard-server:compileJava :reportcard-server:compileTestJava`
2. New tests pass: `./gradlew :reportcard-server:test --tests "*KarateTest*"`
3. All tests pass: `./gradlew :reportcard-server:test`
4. Full build: `./gradlew build`
</verification>

<success_criteria>
1. postStageJunitStorageTarGZ accepts optional karate.tar.gz multipart parameter (API-01)
2. Controller returns 400 when neither junit nor karate provided (API-02)
3. Controller stores karate.tar.gz in S3 with KARATE_JSON storage type (API-03)
4. Controller persists start_time and end_time to run record when Karate JSON present (API-04)
5. Existing JUnit-only uploads continue working unchanged (API-05)
6. Integration tests verify all scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/03-api-integration/03-02-SUMMARY.md`
</output>
