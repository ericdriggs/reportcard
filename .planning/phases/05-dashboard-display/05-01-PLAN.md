---
phase: 05-dashboard-display
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/graph/TestResultGraph.java
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/GraphService.java
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/pipeline/JobDashboardMetrics.java
autonomous: true

must_haves:
  truths:
    - "GraphService query includes start_time and end_time from test_result table"
    - "TestResultGraph record includes startTime and endTime fields"
    - "JobDashboardMetrics calculates avgRunDuration from test_result timing"
    - "NULL timing values are handled gracefully (skipped in calculations)"
    - "Multi-stage runs aggregate correctly (sum per run, then average across runs)"
  artifacts:
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/graph/TestResultGraph.java"
      provides: "startTime and endTime fields added to record"
      contains: "Instant startTime"
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/pipeline/JobDashboardMetrics.java"
      provides: "avgRunDuration field and calculation logic"
      contains: "BigDecimal avgRunDuration"
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/GraphService.java"
      provides: "SELECT includes TEST_RESULT.START_TIME, TEST_RESULT.END_TIME"
      pattern: "TEST_RESULT\\.START_TIME"
  key_links:
    - from: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/GraphService.java"
      to: "TEST_RESULT.START_TIME, TEST_RESULT.END_TIME"
      via: "JOOQ query SELECT"
      pattern: "TEST_RESULT\\.START_TIME.*TEST_RESULT\\.END_TIME"
    - from: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/pipeline/JobDashboardMetrics.java"
      to: "TestResultGraph.startTime(), TestResultGraph.endTime()"
      via: "Duration calculation in fromCompanyGraphs"
      pattern: "testResult\\.startTime\\(\\)"
---

<objective>
Calculate and provide average run duration metrics for dashboard display by extending the data layer to include timing information from test_result table.

Purpose: Enable the dashboard to show job duration (wall clock execution time) alongside existing test metrics. This requires making timing data available through the graph query layer and aggregating it at the job level.

Output: Backend data structures populated with avgRunDuration field, ready for UI rendering.
</objective>

<execution_context>
@/Users/eric.r.driggs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eric.r.driggs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/PROJECT.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/ROADMAP.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/STATE.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/phases/05-dashboard-display/05-CONTEXT.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/phases/05-dashboard-display/05-RESEARCH.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/phases/04.1-migrate-timing-to-test-result/04.1-01-SUMMARY.md

# Relevant source files
@/Users/eric.r.driggs/github/ericdriggs/reportcard/reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/graph/TestResultGraph.java
@/Users/eric.r.driggs/github/ericdriggs/reportcard/reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/pipeline/JobDashboardMetrics.java
@/Users/eric.r.driggs/github/ericdriggs/reportcard/reportcard-model/src/main/java/io/github/ericdriggs/reportcard/util/NumberStringUtil.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add timing fields to TestResultGraph and update GraphService query</name>
  <files>
reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/graph/TestResultGraph.java
reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/GraphService.java
  </files>
  <action>
**1. Add startTime and endTime to TestResultGraph record:**

Edit TestResultGraph.java to add two new fields after the `testResultCreated` field:
- `Instant startTime` - Maps to test_result.start_time (nullable)
- `Instant endTime` - Maps to test_result.end_time (nullable)

The JOOQ-generated TestResultPojo already has these fields (from Phase 4.1), so TestResultGraph needs to match for proper mapping.

Pattern to follow: Look at existing fields like `testResultCreated` (also Instant type). Add the new fields in the record definition and update the `asTestResultPojo()` method to include `.startTime(startTime)` and `.endTime(endTime)` in the builder chain.

**2. Update GraphService query to SELECT timing columns:**

Find the method `getPipelineDashboardCompanyGraphs` (or similar method that builds TestResultGraph for pipeline dashboard).

In the JOOQ query, add to the SELECT list:
- `TEST_RESULT.START_TIME`
- `TEST_RESULT.END_TIME`

Then in the result mapping code where TestResultGraph is constructed, pass these fields to the builder:
- `.startTime(record.get(TEST_RESULT.START_TIME))`
- `.endTime(record.get(TEST_RESULT.END_TIME))`

**Why this matters:** TestResultGraph is the data structure that flows through the dashboard metrics calculation. Without timing in the graph, JobDashboardMetrics cannot calculate duration.

**Critical: @RecordBuilder regeneration:** After modifying TestResultGraph, run `./gradlew build` to trigger @RecordBuilder annotation processing which generates TestResultGraphBuilder class with the new fields.
  </action>
  <verify>
1. `./gradlew build` succeeds and regenerates TestResultGraphBuilder
2. TestResultGraph.java compiles with new startTime/endTime fields
3. GraphService.java compiles with updated SELECT and mapping
4. Grep confirms timing fields present:
   ```bash
   grep -n "Instant startTime" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/graph/TestResultGraph.java
   grep -n "TEST_RESULT.START_TIME" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/GraphService.java
   ```
  </verify>
  <done>
- TestResultGraph record includes `Instant startTime` and `Instant endTime` fields
- TestResultGraph.asTestResultPojo() maps timing fields to POJO
- GraphService query SELECTs TEST_RESULT.START_TIME and TEST_RESULT.END_TIME
- GraphService maps timing columns to TestResultGraph builder
- Build succeeds, RecordBuilder generates updated builder class
  </done>
</task>

<task type="auto">
  <name>Task 2: Calculate avgRunDuration in JobDashboardMetrics</name>
  <files>
reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/pipeline/JobDashboardMetrics.java
  </files>
  <action>
**1. Add avgRunDuration field to JobDashboardMetrics:**

After the `testPassPercent` field, add:
```java
BigDecimal avgRunDuration; // Average duration in seconds, null if no timing data available
```

Update the builder in `fromCompanyGraphs` to include `.avgRunDuration(avgDuration)` where avgDuration is calculated.

**2. Implement duration calculation logic in fromCompanyGraphs method:**

Within the loop over jobGraph.runs(), add aggregation logic:

```java
// Calculate average run duration
// Strategy: For each run, sum all test_result durations (multi-stage support)
// Then average across all runs that have timing data
List<BigDecimal> runDurations = new ArrayList<>();

for (RunGraph run : runs) {
    BigDecimal runTotalSeconds = BigDecimal.ZERO;
    boolean hasAnyTiming = false;

    for (StageGraph stage : emptyIfNull(run.stages())) {
        for (TestResultGraph testResult : emptyIfNull(stage.testResults())) {
            Instant start = testResult.startTime();
            Instant end = testResult.endTime();

            if (start != null && end != null) {
                Duration duration = Duration.between(start, end);
                BigDecimal seconds = BigDecimal.valueOf(duration.getSeconds())
                    .add(BigDecimal.valueOf(duration.getNano())
                    .divide(BigDecimal.valueOf(1_000_000_000), 2, RoundingMode.HALF_UP));
                runTotalSeconds = runTotalSeconds.add(seconds);
                hasAnyTiming = true;
            }
        }
    }

    if (hasAnyTiming) {
        runDurations.add(runTotalSeconds);
    }
}

BigDecimal avgDuration = null;
if (!runDurations.isEmpty()) {
    BigDecimal sum = runDurations.stream().reduce(BigDecimal.ZERO, BigDecimal::add);
    avgDuration = sum.divide(BigDecimal.valueOf(runDurations.size()), 2, RoundingMode.HALF_UP);
}
```

Add needed imports:
- `java.time.Duration`
- `java.math.RoundingMode`

**Why this aggregation strategy:**
- Per CONTEXT.md: "Run Duration = SUM of all test_result durations for that run"
- Multi-stage runs: A single run may have multiple stages (1:1 stage:test_result), so sum them
- NULL handling: Only include runs that have at least some timing data
- Average across runs: User wants typical job duration, so average run totals

**Critical:** This calculation must handle NULL gracefully. Old data (pre-Phase 4.1) has NULL timing. Only calculate average from runs with timing data.
  </action>
  <verify>
1. `./gradlew build` succeeds
2. JobDashboardMetrics.java compiles with avgRunDuration field
3. Grep confirms calculation logic present:
   ```bash
   grep -n "Duration.between" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/pipeline/JobDashboardMetrics.java
   grep -n "avgRunDuration" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/pipeline/JobDashboardMetrics.java
   ```
4. Code review: NULL checks present for start/end time before Duration.between
  </verify>
  <done>
- JobDashboardMetrics has avgRunDuration field (BigDecimal, nullable)
- fromCompanyGraphs calculates run durations by summing test_result timing per run
- Calculation averages run durations across all runs with timing data
- NULL timing values are skipped (not included in average)
- Duration.between converts Instant to Duration, then to seconds as BigDecimal
- Imports added for Duration and RoundingMode
  </done>
</task>

<task type="auto">
  <name>Task 3: Write unit tests for duration calculation</name>
  <files>
reportcard-server/src/test/java/io/github/ericdriggs/reportcard/model/pipeline/JobDashboardMetricsTest.java
  </files>
  <action>
Create test class JobDashboardMetricsTest.java in the appropriate test directory (mirror the main source package structure).

**Test scenarios:**

1. **testAvgRunDuration_withValidTiming** - Verify correct averaging
   - Create CompanyGraph with 2 runs, each run has 1 stage with 1 test_result
   - Run 1: start=T0, end=T0+100s → 100s duration
   - Run 2: start=T0, end=T0+200s → 200s duration
   - Expected avgRunDuration: 150.00 seconds

2. **testAvgRunDuration_withNullTiming** - Verify NULL handling
   - Create CompanyGraph with 3 runs
   - Run 1: start=NULL, end=NULL (old data)
   - Run 2: start=T0, end=T0+100s → 100s duration
   - Run 3: start=T0, end=T0+200s → 200s duration
   - Expected avgRunDuration: 150.00 seconds (Run 1 excluded from average)

3. **testAvgRunDuration_allNullTiming** - Verify all-NULL case
   - Create CompanyGraph with 2 runs, both have NULL timing
   - Expected avgRunDuration: null

4. **testAvgRunDuration_multiStage** - Verify multi-stage aggregation
   - Create CompanyGraph with 1 run containing 2 stages
   - Stage 1 test_result: start=T0, end=T0+100s → 100s
   - Stage 2 test_result: start=T0, end=T0+50s → 50s
   - Expected avgRunDuration: 150.00 seconds (sum of both stages for the run)

Use builder pattern to construct test data (CompanyGraphBuilder, OrgGraphBuilder, etc.). Follow existing test patterns in the codebase.

**Why these tests:** Duration calculation has complex NULL handling and multi-stage aggregation logic. Tests prevent regressions and document expected behavior.
  </action>
  <verify>
Run tests:
```bash
./gradlew test --tests "io.github.ericdriggs.reportcard.model.pipeline.JobDashboardMetricsTest"
```
All 4 test methods pass.
  </verify>
  <done>
- JobDashboardMetricsTest.java created with 4 test methods
- Tests cover: valid timing, NULL timing, all-NULL, multi-stage aggregation
- All tests pass
- Test data constructed using graph builder patterns
  </done>
</task>

</tasks>

<verification>
**Integration verification:**

1. Build succeeds with no compilation errors:
   ```bash
   ./gradlew build
   ```

2. Verify TestResultGraph has timing fields:
   ```bash
   grep "Instant startTime" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/graph/TestResultGraph.java
   ```

3. Verify GraphService queries timing:
   ```bash
   grep "TEST_RESULT.START_TIME" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/GraphService.java
   ```

4. Verify JobDashboardMetrics calculates duration:
   ```bash
   grep "avgRunDuration" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/model/pipeline/JobDashboardMetrics.java
   ```

5. Run all tests in pipeline package:
   ```bash
   ./gradlew test --tests "io.github.ericdriggs.reportcard.model.pipeline.*"
   ```
</verification>

<success_criteria>
- TestResultGraph includes startTime and endTime fields (Instant type)
- GraphService SELECT includes TEST_RESULT.START_TIME and TEST_RESULT.END_TIME
- GraphService maps timing columns to TestResultGraph builder
- JobDashboardMetrics has avgRunDuration field (BigDecimal, nullable)
- Duration calculation aggregates per run (sum stages), then averages across runs
- NULL timing values are handled gracefully (excluded from calculation)
- Unit tests verify calculation correctness across 4 scenarios
- Build succeeds, all existing tests still pass
- @RecordBuilder regenerates TestResultGraphBuilder with new fields
</success_criteria>

<output>
After completion, create `.planning/phases/05-dashboard-display/05-01-SUMMARY.md` following the template structure with performance metrics, accomplishments, decisions made, and files modified.
</output>
