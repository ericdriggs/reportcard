---
phase: 02-latest-endpoints
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java
  - reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonControllerTest.java
autonomous: true

must_haves:
  truths:
    - "User can call /job/{jobId}/run/latest and receive latest run stages"
    - "Response shape matches existing /run/{runId} endpoint exactly"
    - "404 returned when job has no runs"
  artifacts:
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java"
      provides: "getLatestRunStages endpoint"
      contains: "/run/latest"
    - path: "reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonControllerTest.java"
      provides: "Integration tests for latest run endpoint"
      contains: "getLatestRunStagesJsonSuccessTest"
  key_links:
    - from: "BrowseJsonController.getLatestRunStages"
      to: "BrowseService.getLatestRunId"
      via: "method call to resolve run ID"
      pattern: "browseService\\.getLatestRunId"
    - from: "BrowseJsonController.getLatestRunStages"
      to: "RunStagesTestResultsCacheMap"
      via: "delegation to existing cache"
      pattern: "RunStagesTestResultsCacheMap\\.INSTANCE\\.getValue"
---

<objective>
Add latest run endpoint to BrowseJsonController

Purpose: Enable CI/CD pipelines to fetch latest run stages without knowing the run ID upfront.
Output: `/job/{jobId}/run/latest` endpoint with integration test coverage.
</objective>

<execution_context>
@/Users/eric.r.driggs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eric.r.driggs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-latest-endpoints/02-CONTEXT.md
@.planning/phases/02-latest-endpoints/02-RESEARCH.md
@.planning/phases/02-latest-endpoints/02-01-SUMMARY.md

# Source files
@reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java
@reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonControllerTest.java
@reportcard-server/src/test/java/io/github/ericdriggs/reportcard/gen/db/TestData.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getLatestRunStages endpoint to BrowseJsonController</name>
  <files>reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java</files>
  <action>
Add the following endpoint to BrowseJsonController (after the getStagesByIds endpoint, around line 90):

```java
@GetMapping(path = "company/{company}/org/{org}/repo/{repo}/branch/{branch}/job/{jobId}/run/latest",
            produces = "application/json")
public ResponseEntity<Map<RunPojo, Map<StagePojo, Set<io.github.ericdriggs.reportcard.gen.db.tables.pojos.TestResultPojo>>>> getLatestRunStages(
        @PathVariable String company,
        @PathVariable String org,
        @PathVariable String repo,
        @PathVariable String branch,
        @PathVariable Long jobId) {
    Long latestRunId = browseService.getLatestRunId(jobId);
    return getStagesByIds(company, org, repo, branch, jobId, latestRunId);
}
```

Spring MVC literal path matching ensures `/run/latest` matches before `/run/{runId}`. The endpoint resolves the latest run ID, then delegates to the existing `getStagesByIds` method to ensure identical response shape.
  </action>
  <verify>
File compiles: `cd /Users/eric.r.driggs/github/ericdriggs/reportcard-browse-json && ./gradlew :reportcard-server:compileJava --quiet`
  </verify>
  <done>
getLatestRunStages endpoint added with path `/company/{company}/org/{org}/repo/{repo}/branch/{branch}/job/{jobId}/run/latest` that delegates to existing getStagesByIds method.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for latest run endpoint</name>
  <files>reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonControllerTest.java</files>
  <action>
Add the following tests to BrowseJsonControllerTest (after getStageTestResultsTestSuitesJsonSuccessTest, around line 388, before the SHA Lookup section):

```java
// ==================== Latest Run Endpoint Tests ====================

@Test
void getLatestRunStagesJsonSuccessTest() {
    // Call latest run endpoint
    ResponseEntity<Map<RunPojo, Map<StagePojo, Set<TestResultPojo>>>> response =
        controller.getLatestRunStages(TestData.company, TestData.org, TestData.repo,
            TestData.branch, TestData.jobId);

    // Verify HTTP response
    assertNotNull(response);
    assertEquals(HttpStatus.OK, response.getStatusCode());

    // Verify response body
    Map<RunPojo, Map<StagePojo, Set<TestResultPojo>>> runStagesTestResults = response.getBody();
    assertNotNull(runStagesTestResults);
    assertFalse(runStagesTestResults.isEmpty());

    // Verify this is indeed the latest run
    RunPojo latestRun = runStagesTestResults.keySet().iterator().next();
    assertNotNull(latestRun.getRunId(), "Run ID should not be null");

    // Verify stages are present
    Map<StagePojo, Set<TestResultPojo>> stageTestResults = runStagesTestResults.get(latestRun);
    assertNotNull(stageTestResults);
    assertFalse(stageTestResults.isEmpty());

    // Verify expected stage exists
    boolean stageFound = false;
    for (StagePojo stage : stageTestResults.keySet()) {
        if (stage.getStageName().equals(TestData.stage)) {
            stageFound = true;
            break;
        }
    }
    assertTrue(stageFound, "Expected stage '" + TestData.stage + "' not found in response");
}

@Test
void getLatestRunStagesJsonSameAsIdBasedTest() {
    // Get latest run ID directly
    Long latestRunId = browseService.getLatestRunId(TestData.jobId);

    // Call latest endpoint
    ResponseEntity<Map<RunPojo, Map<StagePojo, Set<TestResultPojo>>>> latestResponse =
        controller.getLatestRunStages(TestData.company, TestData.org, TestData.repo,
            TestData.branch, TestData.jobId);

    // Call ID-based endpoint with resolved run ID
    ResponseEntity<Map<RunPojo, Map<StagePojo, Set<TestResultPojo>>>> idBasedResponse =
        controller.getStagesByIds(TestData.company, TestData.org, TestData.repo,
            TestData.branch, TestData.jobId, latestRunId);

    // Verify both responses return same run
    assertNotNull(latestResponse.getBody());
    assertNotNull(idBasedResponse.getBody());

    RunPojo latestRun = latestResponse.getBody().keySet().iterator().next();
    RunPojo idBasedRun = idBasedResponse.getBody().keySet().iterator().next();

    assertEquals(idBasedRun.getRunId(), latestRun.getRunId(),
        "Latest endpoint should return same run ID as ID-based endpoint");
}

@Test
void getLatestRunStagesJsonNotFoundTest() {
    // Job ID with no runs
    Long nonExistentJobId = 999999L;

    ResponseStatusException ex = assertThrows(ResponseStatusException.class, () -> {
        controller.getLatestRunStages(TestData.company, TestData.org, TestData.repo,
            TestData.branch, nonExistentJobId);
    });

    assertEquals(404, ex.getStatus().value(), "Expected 404 status for job with no runs");
}
```

These tests verify: (1) success case returns expected data, (2) response matches ID-based endpoint, (3) 404 for job with no runs.
  </action>
  <verify>
Run tests: `cd /Users/eric.r.driggs/github/ericdriggs/reportcard-browse-json && ./gradlew :reportcard-server:test --tests "io.github.ericdriggs.reportcard.controller.browse.BrowseJsonControllerTest.getLatestRunStages*" --quiet`
  </verify>
  <done>
All three tests pass - success case returns expected data, response matches ID-based endpoint, 404 for job with no runs.
  </done>
</task>

</tasks>

<verification>
1. Compile check: `./gradlew :reportcard-server:compileJava --quiet` - no errors
2. Test run: `./gradlew :reportcard-server:test --tests "*BrowseJsonControllerTest*" --quiet` - all tests pass
3. Endpoint exists: grep for `run/latest` in BrowseJsonController.java shows the endpoint
</verification>

<success_criteria>
- [ ] `/job/{jobId}/run/latest` endpoint added to BrowseJsonController
- [ ] Endpoint resolves latest run ID using browseService.getLatestRunId()
- [ ] Endpoint delegates to existing getStagesByIds method
- [ ] Response shape identical to ID-based endpoint
- [ ] getLatestRunStagesJsonSuccessTest passes
- [ ] getLatestRunStagesJsonSameAsIdBasedTest passes
- [ ] getLatestRunStagesJsonNotFoundTest passes
- [ ] All existing BrowseJsonControllerTest tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-latest-endpoints/02-02-SUMMARY.md`
</output>
