---
phase: 02-latest-endpoints
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java
  - reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonControllerTest.java
autonomous: true

must_haves:
  truths:
    - "User can call /job/{jobId}/run/latest/stage/{stage} and receive stage test results"
    - "Response shape matches existing /run/{runId}/stage/{stage} endpoint exactly"
    - "404 returned when job has no runs"
  artifacts:
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java"
      provides: "getLatestRunStageTestResults endpoint"
      contains: "/run/latest/stage/"
    - path: "reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonControllerTest.java"
      provides: "Integration tests for latest stage endpoint"
      contains: "getLatestRunStageTestResultsJsonSuccessTest"
  key_links:
    - from: "BrowseJsonController.getLatestRunStageTestResults"
      to: "BrowseService.getLatestRunId"
      via: "method call to resolve run ID"
      pattern: "browseService\\.getLatestRunId"
    - from: "BrowseJsonController.getLatestRunStageTestResults"
      to: "BrowseService.getStageTestResultMap"
      via: "delegation to existing method"
      pattern: "browseService\\.getStageTestResultMap"
---

<objective>
Add latest stage endpoint to BrowseJsonController

Purpose: Enable CI/CD pipelines to fetch specific stage test results from the latest run without knowing the run ID upfront.
Output: `/job/{jobId}/run/latest/stage/{stage}` endpoint with integration test coverage.
</objective>

<execution_context>
@/Users/eric.r.driggs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eric.r.driggs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-latest-endpoints/02-CONTEXT.md
@.planning/phases/02-latest-endpoints/02-RESEARCH.md
@.planning/phases/02-latest-endpoints/02-01-SUMMARY.md

# Source files
@reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java
@reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonControllerTest.java
@reportcard-server/src/test/java/io/github/ericdriggs/reportcard/gen/db/TestData.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getLatestRunStageTestResults endpoint to BrowseJsonController</name>
  <files>reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java</files>
  <action>
Add the following endpoint to BrowseJsonController (after the getLatestRunStages endpoint added in 02-02, or after getStageTestResultsTestSuites around line 126):

```java
@GetMapping(path = "company/{company}/org/{org}/repo/{repo}/branch/{branch}/job/{jobId}/run/latest/stage/{stage}",
            produces = "application/json")
public ResponseEntity<StageTestResultModel> getLatestRunStageTestResults(
        @PathVariable String company,
        @PathVariable String org,
        @PathVariable String repo,
        @PathVariable String branch,
        @PathVariable Long jobId,
        @PathVariable String stage) {
    Long latestRunId = browseService.getLatestRunId(jobId);
    return getStageTestResultsTestSuites(company, org, repo, branch, jobId, latestRunId, stage);
}
```

Spring MVC literal path matching ensures `/run/latest/stage/{stage}` matches before `/run/{runId}/stage/{stage}`. The endpoint resolves the latest run ID, then delegates to the existing `getStageTestResultsTestSuites` method to ensure identical response shape.
  </action>
  <verify>
File compiles: `cd /Users/eric.r.driggs/github/ericdriggs/reportcard-browse-json && ./gradlew :reportcard-server:compileJava --quiet`
  </verify>
  <done>
getLatestRunStageTestResults endpoint added with path `/company/{company}/org/{org}/repo/{repo}/branch/{branch}/job/{jobId}/run/latest/stage/{stage}` that delegates to existing getStageTestResultsTestSuites method.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for latest stage endpoint</name>
  <files>reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonControllerTest.java</files>
  <action>
Add the following tests to BrowseJsonControllerTest (after the latest run endpoint tests, before the SHA Lookup section):

```java
@Test
void getLatestRunStageTestResultsJsonSuccessTest() {
    // Call latest stage endpoint
    ResponseEntity<StageTestResultModel> response =
        controller.getLatestRunStageTestResults(TestData.company, TestData.org, TestData.repo,
            TestData.branch, TestData.jobId, TestData.stage);

    // Verify HTTP response
    assertNotNull(response);
    assertEquals(HttpStatus.OK, response.getStatusCode());

    // Verify response body
    StageTestResultModel stageTestResultModel = response.getBody();
    assertNotNull(stageTestResultModel, "StageTestResultModel should not be null");

    // Verify stage details
    assertNotNull(stageTestResultModel.getStage(), "Stage should not be null");
    assertEquals(TestData.stage, stageTestResultModel.getStage().getStageName(),
        "Stage name should match TestData.stage");

    // Verify test result data
    assertNotNull(stageTestResultModel.getTestResult(), "TestResult should not be null");
    assertNotNull(stageTestResultModel.getTestResult().getTestSuites(),
        "Test suites should not be null");
    assertFalse(stageTestResultModel.getTestResult().getTestSuites().isEmpty(),
        "Test suites should not be empty");

    // Verify test cases exist
    boolean hasTestCases = stageTestResultModel.getTestResult().getTestSuites().stream()
        .anyMatch(suite -> suite.getTestCases() != null && !suite.getTestCases().isEmpty());
    assertTrue(hasTestCases, "At least one test suite should contain test cases");
}

@Test
void getLatestRunStageTestResultsJsonSameAsIdBasedTest() {
    // Get latest run ID directly
    Long latestRunId = browseService.getLatestRunId(TestData.jobId);

    // Call latest endpoint
    ResponseEntity<StageTestResultModel> latestResponse =
        controller.getLatestRunStageTestResults(TestData.company, TestData.org, TestData.repo,
            TestData.branch, TestData.jobId, TestData.stage);

    // Call ID-based endpoint with resolved run ID
    ResponseEntity<StageTestResultModel> idBasedResponse =
        controller.getStageTestResultsTestSuites(TestData.company, TestData.org, TestData.repo,
            TestData.branch, TestData.jobId, latestRunId, TestData.stage);

    // Verify both responses return same stage
    assertNotNull(latestResponse.getBody());
    assertNotNull(idBasedResponse.getBody());

    StageTestResultModel latestModel = latestResponse.getBody();
    StageTestResultModel idBasedModel = idBasedResponse.getBody();

    assertEquals(idBasedModel.getStage().getStageId(), latestModel.getStage().getStageId(),
        "Latest endpoint should return same stage ID as ID-based endpoint");
    assertEquals(idBasedModel.getTestResult().getTestResultId(),
        latestModel.getTestResult().getTestResultId(),
        "Latest endpoint should return same test result ID as ID-based endpoint");
}

@Test
void getLatestRunStageTestResultsJsonNotFoundTest() {
    // Job ID with no runs
    Long nonExistentJobId = 999999L;

    ResponseStatusException ex = assertThrows(ResponseStatusException.class, () -> {
        controller.getLatestRunStageTestResults(TestData.company, TestData.org, TestData.repo,
            TestData.branch, nonExistentJobId, TestData.stage);
    });

    assertEquals(404, ex.getStatus().value(), "Expected 404 status for job with no runs");
}
```

These tests verify: (1) success case returns expected data with test suites, (2) response matches ID-based endpoint, (3) 404 for job with no runs.
  </action>
  <verify>
Run tests: `cd /Users/eric.r.driggs/github/ericdriggs/reportcard-browse-json && ./gradlew :reportcard-server:test --tests "io.github.ericdriggs.reportcard.controller.browse.BrowseJsonControllerTest.getLatestRunStageTestResults*" --quiet`
  </verify>
  <done>
All three tests pass - success case returns expected data with test suites/cases, response matches ID-based endpoint, 404 for job with no runs.
  </done>
</task>

</tasks>

<verification>
1. Compile check: `./gradlew :reportcard-server:compileJava --quiet` - no errors
2. Test run: `./gradlew :reportcard-server:test --tests "*BrowseJsonControllerTest*" --quiet` - all tests pass
3. Endpoint exists: grep for `run/latest/stage` in BrowseJsonController.java shows the endpoint
</verification>

<success_criteria>
- [ ] `/job/{jobId}/run/latest/stage/{stage}` endpoint added to BrowseJsonController
- [ ] Endpoint resolves latest run ID using browseService.getLatestRunId()
- [ ] Endpoint delegates to existing getStageTestResultsTestSuites method
- [ ] Response shape identical to ID-based endpoint (StageTestResultModel)
- [ ] getLatestRunStageTestResultsJsonSuccessTest passes
- [ ] getLatestRunStageTestResultsJsonSameAsIdBasedTest passes
- [ ] getLatestRunStageTestResultsJsonNotFoundTest passes
- [ ] All existing BrowseJsonControllerTest tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-latest-endpoints/02-03-SUMMARY.md`
</output>
