---
phase: 04.1-migrate-timing-to-test-result
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - reportcard-server/src/main/resources/db/migration/V1.0__reportcard_mysql_ddl.sql
  - reportcard-server/src/generated/java/io/github/ericdriggs/reportcard/gen/db/tables/TestResultTable.java
  - reportcard-server/src/generated/java/io/github/ericdriggs/reportcard/gen/db/tables/records/TestResultRecord.java
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/StagePathPersistService.java
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java
autonomous: true

must_haves:
  truths:
    - "test_result table has start_time and end_time columns in MySQL schema"
    - "JOOQ TEST_RESULT class provides start_time and end_time accessors"
    - "Controller writes timing data to test_result table instead of run table"
    - "Existing JUnit-only uploads continue working unchanged"
    - "Karate uploads populate test_result timing instead of run timing"
  artifacts:
    - path: "reportcard-server/src/main/resources/db/migration/V1.0__reportcard_mysql_ddl.sql"
      provides: "test_result table with start_time and end_time columns"
      contains: "ADD COLUMN start_time DATETIME NULL"
    - path: "reportcard-server/src/generated/java/io/github/ericdriggs/reportcard/gen/db/tables/TestResultTable.java"
      provides: "JOOQ TEST_RESULT.START_TIME and TEST_RESULT.END_TIME fields"
      exports: ["START_TIME", "END_TIME"]
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/StagePathPersistService.java"
      provides: "updateTestResultTiming method"
      contains: "updateTestResultTiming.*Long testResultId.*Instant startTime.*Instant endTime"
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java"
      provides: "Controller calls updateTestResultTiming with testResultId"
      pattern: "processKarateTiming.*testResultId"
  key_links:
    - from: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java"
      to: "StagePathPersistService.updateTestResultTiming"
      via: "processKarateTiming method"
      pattern: "stagePathPersistService\\.updateTestResultTiming\\(testResultId"
    - from: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/StagePathPersistService.java"
      to: "TEST_RESULT table"
      via: "JOOQ DSL update"
      pattern: "dsl\\.update\\(TEST_RESULT\\)"
---

<objective>
Migrate timing columns from run table to test_result table to support per-stage timing in multi-stage runs.

Purpose: Multi-stage runs need independent timing per stage rather than shared run-level timing. This enables accurate wall clock reporting for each test stage.

Output: Schema updated, JOOQ regenerated, persistence and controller layers updated to write timing data to test_result instead of run.
</objective>

<execution_context>
@/Users/eric.r.driggs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eric.r.driggs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/PROJECT.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/ROADMAP.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/STATE.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/phases/04.1-migrate-timing-to-test-result/04.1-RESEARCH.md

# Prior phase patterns
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/phases/01-schema-foundation/01-01-SUMMARY.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/phases/03-api-integration/03-01-SUMMARY.md
@/Users/eric.r.driggs/github/ericdriggs/reportcard/.planning/phases/03-api-integration/03-02-SUMMARY.md

# Codebase guidance
@/Users/eric.r.driggs/github/ericdriggs/reportcard/CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Add timing columns to test_result table and regenerate JOOQ</name>
  <files>
    reportcard-server/src/main/resources/db/migration/V1.0__reportcard_mysql_ddl.sql
    reportcard-server/src/generated/java/io/github/ericdriggs/reportcard/gen/db/tables/TestResultTable.java
    reportcard-server/src/generated/java/io/github/ericdriggs/reportcard/gen/db/tables/records/TestResultRecord.java
  </files>
  <action>
    1. Edit V1.0__reportcard_mysql_ddl.sql to add start_time and end_time columns to test_result table:
       - Position AFTER the existing `time` column (line ~245)
       - Both columns DATETIME NULL for backwards compatibility
       - Add comments: 'Start time of stage execution (from Karate or other timing source)' and 'End time of stage execution (from Karate or other timing source)'
       - DO NOT modify or remove run.start_time/end_time columns (backward compatibility)

    2. Apply schema change to local MySQL manually:
       ```bash
       mysql -u reportcard -p reportcard <<EOF
       ALTER TABLE test_result
           ADD COLUMN start_time DATETIME NULL COMMENT 'Start time of stage execution' AFTER time,
           ADD COLUMN end_time DATETIME NULL COMMENT 'End time of stage execution' AFTER start_time;
       EOF
       ```

    3. Regenerate JOOQ classes:
       ```bash
       export JAVA_HOME=$(/usr/libexec/java_home -v 17)
       ./gradlew generateJooqSchemaSource
       ```

    4. Verify generated files include new timing fields:
       - TestResultTable.java should have START_TIME and END_TIME TableField<TestResultRecord, Instant> fields
       - TestResultRecord.java should have getStartTime/setStartTime/getEndTime/setEndTime methods

    CRITICAL: JOOQ regeneration MUST complete successfully before writing business logic. Task 2 depends on TEST_RESULT.START_TIME and TEST_RESULT.END_TIME being available.
  </action>
  <verify>
    ```bash
    # Verify schema change applied
    mysql -u reportcard -p reportcard -e "DESCRIBE test_result;" | grep -E "start_time|end_time"

    # Verify JOOQ generated files updated
    grep -E "START_TIME|END_TIME" reportcard-server/src/generated/java/io/github/ericdriggs/reportcard/gen/db/tables/TestResultTable.java

    # Verify build succeeds with new schema
    ./gradlew compileJava
    ```
  </verify>
  <done>
    - test_result table has start_time and end_time columns (DATETIME NULL) positioned after time column
    - JOOQ TestResultTable.java contains START_TIME and END_TIME field declarations
    - JOOQ TestResultRecord.java contains getStartTime/setStartTime/getEndTime/setEndTime methods
    - Gradle compileJava succeeds with updated generated code
  </done>
</task>

<task type="auto">
  <name>Create updateTestResultTiming persistence method</name>
  <files>
    reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/StagePathPersistService.java
  </files>
  <action>
    Add new updateTestResultTiming method to StagePathPersistService.java following the exact pattern of existing updateRunTiming method (lines 371-390):

    ```java
    /**
     * Updates test_result record with start and end times from timing source (e.g., Karate).
     * Does nothing if testResultId is null.
     * Does nothing if both times are null.
     *
     * @param testResultId the test_result ID to update
     * @param startTime the start time (nullable)
     * @param endTime the end time (nullable)
     */
    public void updateTestResultTiming(Long testResultId, Instant startTime, Instant endTime) {
        if (testResultId == null) {
            log.warn("Cannot update test result timing: testResultId is null");
            return;
        }
        if (startTime == null && endTime == null) {
            log.debug("No timing data to update for testResultId: {}", testResultId);
            return;
        }

        int rowsUpdated = dsl.update(TEST_RESULT)
                .set(TEST_RESULT.START_TIME, startTime)
                .set(TEST_RESULT.END_TIME, endTime)
                .where(TEST_RESULT.TEST_RESULT_ID.eq(testResultId))
                .execute();

        if (rowsUpdated != 1) {
            log.warn("Expected 1 row updated for test result timing, actual: {} for testResultId: {}", rowsUpdated, testResultId);
        }
    }
    ```

    Place this method immediately after the existing updateRunTiming method for easy comparison.

    DO NOT remove or modify updateRunTiming method - keep for backward compatibility.

    RATIONALE: Preserve exact same null-handling and logging patterns as updateRunTiming. Uses TEST_RESULT table fields generated in Task 1.
  </action>
  <verify>
    ```bash
    # Verify method exists with correct signature
    grep -A 25 "public void updateTestResultTiming" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/StagePathPersistService.java

    # Verify uses TEST_RESULT.START_TIME and TEST_RESULT.END_TIME
    grep "TEST_RESULT\\.START_TIME\|TEST_RESULT\\.END_TIME" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/persist/StagePathPersistService.java

    # Verify compiles
    ./gradlew :reportcard-server:compileJava
    ```
  </verify>
  <done>
    - StagePathPersistService contains updateTestResultTiming method with signature matching pattern in action
    - Method updates TEST_RESULT.START_TIME and TEST_RESULT.END_TIME using JOOQ DSL
    - Null checks and logging follow same pattern as updateRunTiming
    - Code compiles successfully
  </done>
</task>

<task type="auto">
  <name>Update controller to use testResultId and new persistence method</name>
  <files>
    reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java
  </files>
  <action>
    Update JunitController to call updateTestResultTiming with testResultId instead of updateRunTiming with runId:

    1. In doPostStageJunitStorageTarGZ method (around line 254-261):
       - Change: `final Long runId = stagePath.getRun().getRunId();`
       - To: `final Long testResultId = stagePathTestResult.getTestResult().getTestResultId();`
       - Update call: `processKarateTiming(testResultId, req.getKarateTarGz());` instead of `processKarateTiming(runId, req.getKarateTarGz());`

    2. In processKarateTiming method (lines 328-352):
       - Change method signature: `private void processKarateTiming(Long testResultId, MultipartFile karateTarGz)`
       - Update all log messages to reference testResultId instead of runId
       - Change service call: `stagePathPersistService.updateTestResultTiming(testResultId, startInstant, endInstant);`

    3. Run integration tests to verify:
       ```bash
       ./gradlew :reportcard-server:test --tests "JunitControllerKarateTest"
       ```

    RATIONALE: Controller data flow changes from runId to testResultId. The stagePathTestResult object already contains testResultId (verified in research: line 254 creates StagePathTestResult with TestResultModel). Method signature change and call site must update together to maintain consistency.

    IMPORTANT: Existing tests should pass without modification because the behavior is identical (writing timing data), just to a different table. If tests fail, it indicates a problem with the implementation, not the tests.
  </action>
  <verify>
    ```bash
    # Verify testResultId extraction
    grep "testResultId = stagePathTestResult.getTestResult().getTestResultId()" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java

    # Verify processKarateTiming signature updated
    grep "private void processKarateTiming(Long testResultId" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java

    # Verify calls updateTestResultTiming
    grep "stagePathPersistService.updateTestResultTiming(testResultId" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java

    # Verify tests pass
    ./gradlew :reportcard-server:test --tests "JunitControllerKarateTest"
    ```
  </verify>
  <done>
    - JunitController extracts testResultId from stagePathTestResult instead of runId from stagePath
    - processKarateTiming method signature changed to accept Long testResultId parameter
    - processKarateTiming calls stagePathPersistService.updateTestResultTiming with testResultId
    - All log messages in processKarateTiming reference testResultId
    - JunitControllerKarateTest integration tests pass (all scenarios: junit-only, karate-only, combined)
  </done>
</task>

</tasks>

<verification>
End-to-end verification after all tasks complete:

```bash
# Verify schema change
mysql -u reportcard -p reportcard -e "SELECT test_result_id, start_time, end_time FROM test_result LIMIT 1;"

# Verify full build succeeds
./gradlew build

# Verify integration tests pass
./gradlew :reportcard-server:integrationTest --tests "*KarateTest"

# Verify no references to old updateRunTiming in controller
! grep "processKarateTiming.*runId" reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/JunitController.java
```
</verification>

<success_criteria>
1. test_result table has start_time and end_time columns (DATETIME NULL) in MySQL schema
2. JOOQ generated classes include TEST_RESULT.START_TIME and TEST_RESULT.END_TIME fields
3. StagePathPersistService.updateTestResultTiming method exists and updates test_result table
4. JunitController extracts testResultId and calls updateTestResultTiming
5. Integration tests pass proving Karate uploads write timing to test_result table
6. Existing JUnit-only uploads continue working (backwards compatible)
7. Full build succeeds with no compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-migrate-timing-to-test-result/04.1-01-SUMMARY.md` following the template structure.
</output>
