# Phase 4.1: Migrate Timing to Test Result - Research

**Researched:** 2026-01-27
**Domain:** Database schema migration (MySQL), JOOQ code generation, data migration patterns
**Confidence:** HIGH

## Summary

This phase involves migrating timing columns (start_time, end_time) from the `run` table to the `test_result` table to support per-stage timing in multi-stage runs. Research confirms:

1. **1:1 Relationship Verified**: test_result has `UNIQUE INDEX stage_fk_UNIQUE` ensuring 1:1 with stage (schema line 246)
2. **Current Implementation Located**: `StagePathPersistService.updateRunTiming()` (lines 371-390) writes to RUN.START_TIME and RUN.END_TIME
3. **Controller Access Pattern**: JunitController creates `StagePathTestResult` at line 254, which contains both `StagePath` and `TestResultModel` with testResultId
4. **Zero External Usage**: Only updateRunTiming() references RUN.START_TIME/END_TIME - no queries, reports, or other consumers exist
5. **JOOQ Workflow Confirmed**: Manual DB update required before `./gradlew generateJooqSchemaSource`

**Primary recommendation:** Additive-only migration with backward compatibility. Add new columns to test_result, update code to write to both locations temporarily, then remove run columns in future phase if desired.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| MySQL | 8.0 | Database | ALTER TABLE for column additions |
| JOOQ | 3.18.7 | Type-safe DB access | Code generation from schema |
| Gradle | 8.5 | Build system | generateJooqSchemaSource task |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Testcontainers | 1.19.3 | Test database | Integration test verification |
| Flyway | N/A | NOT USED | Despite V*.sql naming, migrations are manual |

**Key Constraint:** This codebase does NOT use Flyway. Schema files named `V1.0__`, `V1.1__` are convention only. All schema changes require manual MySQL execution.

**Installation:**
Already installed - no new dependencies required.

## Architecture Patterns

### Recommended Migration Structure

**Phase 4.1 focuses on additive changes only:**

```
1. Schema DDL (manual execution)
2. JOOQ regeneration
3. Persistence layer update
4. Controller update
5. Test verification
```

**Do NOT attempt in Phase 4.1:**
- Removing run.start_time/end_time (backward compatibility)
- Migrating existing data (out of scope)
- Updating queries/reports (none exist)

### Pattern 1: Additive Column Migration

**What:** Add new columns without removing old ones
**When to use:** When backward compatibility is required or migration risk should be minimized
**Example:**

```sql
-- V1.2__add_timing_to_test_result.sql
USE reportcard;

ALTER TABLE test_result
    ADD COLUMN start_time DATETIME NULL AFTER time,
    ADD COLUMN end_time DATETIME NULL AFTER start_time;
```

**Why this pattern:**
- Existing code continues to work
- Rollback is trivial (just don't use new columns)
- Data loss risk eliminated
- Can validate new implementation before removing old columns

### Pattern 2: Update Persistence Method Signature

**What:** Change method to accept test_result_id instead of run_id
**When to use:** When the entity owning the data changes
**Example:**

```java
// BEFORE (Phase 3)
public void updateRunTiming(Long runId, Instant startTime, Instant endTime) {
    dsl.update(RUN)
        .set(RUN.START_TIME, startTime)
        .set(RUN.END_TIME, endTime)
        .where(RUN.RUN_ID.eq(runId))
        .execute();
}

// AFTER (Phase 4.1)
public void updateTestResultTiming(Long testResultId, Instant startTime, Instant endTime) {
    dsl.update(TEST_RESULT)
        .set(TEST_RESULT.START_TIME, startTime)
        .set(TEST_RESULT.END_TIME, endTime)
        .where(TEST_RESULT.TEST_RESULT_ID.eq(testResultId))
        .execute();
}
```

**Note:** TEST_RESULT constant will be available after JOOQ regeneration.

### Pattern 3: Controller Data Flow Update

**What:** Extract testResultId from stagePathTestResult instead of runId from stagePath
**Current code (line 254-261):**

```java
StagePathTestResult stagePathTestResult = testResultPersistService.insertTestResult(req.getStageDetails(), testResultModel);
StagePath stagePath = stagePathTestResult.getStagePath();
final Long stageId = stagePath.getStage().getStageId();
final Long runId = stagePath.getRun().getRunId();  // OLD

// Process Karate timing data
if (hasKarate) {
    processKarateTiming(runId, req.getKarateTarGz());  // OLD
}
```

**Updated pattern:**

```java
StagePathTestResult stagePathTestResult = testResultPersistService.insertTestResult(req.getStageDetails(), testResultModel);
StagePath stagePath = stagePathTestResult.getStagePath();
final Long stageId = stagePath.getStage().getStageId();
final Long testResultId = stagePathTestResult.getTestResult().getTestResultId();  // NEW

// Process Karate timing data
if (hasKarate) {
    processKarateTiming(testResultId, req.getKarateTarGz());  // NEW
}
```

### Pattern 4: JOOQ Regeneration Workflow

**Mandatory sequence for ALL schema changes:**

```bash
# 1. Create SQL file
# .../db/migration/V1.X__description.sql

# 2. Apply to local MySQL manually
mysql -u reportcard -p reportcard < src/main/resources/db/migration/V1.X__description.sql

# 3. Regenerate JOOQ classes
./gradlew generateJooqSchemaSource

# 4. Verify generated files
ls -la src/generated/java/io/github/ericdriggs/reportcard/gen/db/tables/TestResultTable.java

# 5. Now write code using new columns
```

**Critical:** Step 3 MUST complete before writing any business logic. Generated classes define available columns.

### Anti-Patterns to Avoid

- **Editing generated JOOQ code directly**: Files in `src/generated/` are overwritten. Always regenerate from schema.
- **Using Flyway mindset**: No automatic migrations. Every schema change requires manual MySQL execution.
- **Removing old columns immediately**: Keep run.start_time/end_time for backward compatibility until proven unnecessary.
- **Skipping JOOQ regeneration**: Code will compile with stale definitions but fail at runtime with "column not found" errors.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Data migration between columns | Custom migration script | Manual UPDATE statement | Simple one-time operation, no need for framework |
| Column existence checking | Runtime reflection | Trust JOOQ generated classes | JOOQ provides type safety, runtime checks add complexity |
| Backward compatibility layer | Wrapper methods | Direct migration with additive-only changes | Simpler to add columns and update code than maintain dual-write logic |
| Schema version tracking | Custom version table | Convention (V1.X file naming) | Existing codebase pattern - no Flyway needed |

**Key insight:** This is a straightforward column migration. The complexity is in the workflow (manual DB + JOOQ regen), not the migration itself. Don't overcomplicate with frameworks or elaborate migration strategies.

## Common Pitfalls

### Pitfall 1: JOOQ Regeneration Amnesia

**What goes wrong:** Developer modifies schema, applies to MySQL, writes business logic - but forgets to regenerate JOOQ classes. Code compiles (using old generated classes) but fails at runtime with "Unknown column 'test_result.start_time'" errors.

**Why it happens:** The `generateJooqSchemaSource` task is manual, not automatic on build. Gradle will happily compile with stale generated code.

**How to avoid:**
- Add JOOQ regeneration as mandatory step in schema change checklist
- Always verify generated file timestamps after schema changes
- Add comment to top of SQL migration file: "AFTER APPLYING: Run ./gradlew generateJooqSchemaSource"

**Warning signs:**
- Runtime "column not found" errors despite schema changes
- TEST_RESULT.START_TIME not available in IDE autocomplete
- Generated TestResultTable.java modified date is before schema change date

### Pitfall 2: Method Signature Mismatch

**What goes wrong:** Update persistence method signature (runId → testResultId) but forget to update controller call site. Compile error easy to fix, but easy to miss if changing files separately.

**Why it happens:** Three files need coordination: StagePathPersistService.java, JunitController.java, and potentially tests.

**How to avoid:**
- Update method signature and call site in same commit
- Use IDE "Find Usages" on method before changing signature
- Run `./gradlew compileJava` after method signature change to catch all call sites

**Warning signs:**
- Compilation errors referencing updateRunTiming
- Parameter type mismatches (Long runId passed to Long testResultId parameter)

### Pitfall 3: Test Data Assumptions

**What goes wrong:** Integration tests assume timing data exists on run table, fail after migration even though production code works.

**Why it happens:** Tests may query RUN table directly or make assertions about run.start_time/end_time.

**How to avoid:**
- Search for RUN.START_TIME/END_TIME in test files before making changes
- Update test assertions to query test_result table instead
- Run full integration test suite after migration

**Warning signs:**
- Tests pass individually but fail in suite
- Assertions about run timing fail with null values
- Test data setup still writes to run.start_time/end_time

### Pitfall 4: Backward Compatibility Assumption

**What goes wrong:** Removing run.start_time/end_time columns immediately, breaking rollback capability or external tools that may read this data.

**Why it happens:** Desire to "clean up" schema during migration.

**How to avoid:**
- **Phase 4.1 decision**: Keep run columns, only ADD test_result columns
- Mark run columns as deprecated in comments if desired
- Future phase can remove after proving new columns work in production

**Warning signs:**
- Schema includes DROP COLUMN statements in Phase 4.1
- Discussion about "which columns to keep" - answer is BOTH for now

### Pitfall 5: NULL Timing Data Assumptions

**What goes wrong:** Code assumes start_time/end_time are always present, throws NullPointerException when Karate data is not provided.

**Why it happens:** New columns are DATETIME NULL, existing code may not handle nulls properly.

**How to avoid:**
- Keep existing null checks in updateTestResultTiming (lines 372-379 pattern)
- Test with JUnit-only uploads (no Karate data)
- Verify null handling in all timing-related code

**Warning signs:**
- NPE when processing non-Karate uploads
- Missing null checks in new timing method
- Tests fail when karateTarGz is null/empty

## Code Examples

### Schema Migration

```sql
-- V1.2__add_timing_to_test_result.sql
-- Purpose: Add start_time and end_time columns to test_result for per-stage timing
-- AFTER APPLYING: Run ./gradlew generateJooqSchemaSource
-- Related: Phase 4.1 - Migrate Timing to Test Result

USE reportcard;

ALTER TABLE test_result
    ADD COLUMN start_time DATETIME NULL COMMENT 'Start time of stage execution (from Karate or other timing source)' AFTER time,
    ADD COLUMN end_time DATETIME NULL COMMENT 'End time of stage execution (from Karate or other timing source)' AFTER start_time;
```

**Positioning rationale:** Place after `time` column (sum of test durations) since all three are timing-related.

### Updated Persistence Method

```java
// StagePathPersistService.java
// NEW method - replaces updateRunTiming

/**
 * Updates test_result record with start and end times from timing source (e.g., Karate).
 * Does nothing if testResultId is null.
 * Does nothing if both times are null.
 *
 * @param testResultId the test_result ID to update
 * @param startTime the start time (nullable)
 * @param endTime the end time (nullable)
 */
public void updateTestResultTiming(Long testResultId, Instant startTime, Instant endTime) {
    if (testResultId == null) {
        log.warn("Cannot update test result timing: testResultId is null");
        return;
    }
    if (startTime == null && endTime == null) {
        log.debug("No timing data to update for testResultId: {}", testResultId);
        return;
    }

    int rowsUpdated = dsl.update(TEST_RESULT)
            .set(TEST_RESULT.START_TIME, startTime)
            .set(TEST_RESULT.END_TIME, endTime)
            .where(TEST_RESULT.TEST_RESULT_ID.eq(testResultId))
            .execute();

    if (rowsUpdated != 1) {
        log.warn("Expected 1 row updated for test result timing, actual: {} for testResultId: {}", rowsUpdated, testResultId);
    }
}
```

**Note:** Preserve exact same null-handling logic as original updateRunTiming() method.

### Updated Controller Call

```java
// JunitController.java - processKarateTiming method signature change

/**
 * Processes Karate timing data and updates test_result record.
 */
private void processKarateTiming(Long testResultId, MultipartFile karateTarGz) {
    if (karateTarGz == null || karateTarGz.isEmpty()) {
        return;
    }

    String summaryJson = KarateTarGzUtil.extractKarateSummaryJson(karateTarGz);
    if (summaryJson == null) {
        log.warn("karate-summary-json.txt not found in karate.tar.gz for testResultId: {}", testResultId);
        return;
    }

    KarateSummary summary = KarateConvertersUtil.parseKarateSummary(summaryJson);
    if (summary == null) {
        log.warn("Failed to parse karate-summary-json.txt for testResultId: {}", testResultId);
        return;
    }

    LocalDateTime endTime = KarateConvertersUtil.parseResultDate(summary.getResultDate());
    LocalDateTime startTime = KarateConvertersUtil.calculateStartTime(endTime, summary.getElapsedTime());

    Instant startInstant = toInstant(startTime);
    Instant endInstant = toInstant(endTime);

    stagePathPersistService.updateTestResultTiming(testResultId, startInstant, endInstant);
}
```

**Changes:**
- Parameter: `Long runId` → `Long testResultId`
- Log messages: reference testResultId instead of runId
- Service call: `updateRunTiming` → `updateTestResultTiming`

### Updated Controller Call Site

```java
// JunitController.java - doPostStageJunitStorageTarGZ method (around line 254)

StagePathTestResult stagePathTestResult = testResultPersistService.insertTestResult(req.getStageDetails(), testResultModel);
StagePath stagePath = stagePathTestResult.getStagePath();
final Long stageId = stagePath.getStage().getStageId();
final Long testResultId = stagePathTestResult.getTestResult().getTestResultId();  // NEW: extract test_result_id

// Process Karate timing data
if (hasKarate) {
    processKarateTiming(testResultId, req.getKarateTarGz());  // NEW: pass testResultId
}
```

**Changes:**
- Added: `final Long testResultId = stagePathTestResult.getTestResult().getTestResultId();`
- Updated: `processKarateTiming(testResultId, ...)` instead of `processKarateTiming(runId, ...)`
- Removed: `final Long runId = stagePath.getRun().getRunId();` line (no longer needed)

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Timing on run table | Timing on test_result table | Phase 4.1 | Enables per-stage timing for multi-stage runs |
| updateRunTiming() | updateTestResultTiming() | Phase 4.1 | Method signature change reflects entity ownership |
| runId parameter | testResultId parameter | Phase 4.1 | Data flows to correct table |

**Deprecated/outdated:**
- run.start_time and run.end_time columns: Functionally deprecated in Phase 4.1, but kept for backward compatibility
- StagePathPersistService.updateRunTiming(): Replaced by updateTestResultTiming(), can be removed after code migration

**Backward compatibility:**
- Keep run.start_time/end_time columns until Phase 4.1 proven stable in production
- Consider deprecation annotation on updateRunTiming() to warn future developers
- Document in schema comments that test_result columns are source of truth for timing

## Open Questions

### Question 1: Should run.start_time/end_time be removed in Phase 4.1?

**What we know:**
- Only updateRunTiming() writes to these columns (verified by grep)
- No queries, reports, or other consumers found
- Removing columns eliminates confusion about which is source of truth

**What's unclear:**
- Whether external tools (CI/CD, reporting) directly query run table
- Whether rollback strategy requires keeping old columns
- Whether run-level timing has future use case (aggregated across stages)

**Recommendation:**
- **KEEP columns in Phase 4.1** (additive-only migration)
- Add schema comments marking them as deprecated
- Remove in future phase after production validation
- If removal desired later, create Phase 4.2 for cleanup

### Question 2: Should data migration populate existing records?

**What we know:**
- Scope says "Existing data handled gracefully"
- No specific requirement to migrate historical data
- New columns are NULLable, so missing data is valid state

**What's unclear:**
- Whether historical timing data exists in run table
- Whether reports/analytics need complete historical timing at test_result level
- Whether effort of data migration justifies benefit

**Recommendation:**
- **NO data migration in Phase 4.1** - out of scope
- New uploads will populate test_result.start_time/end_time
- Historical data remains in run table only
- If needed later, create separate data migration phase with UPDATE statement

### Question 3: Should both run and test_result timing be populated temporarily?

**What we know:**
- Additive migration preserves run columns
- Could write to both locations during transition

**What's unclear:**
- Whether dual-write adds value vs. complexity
- How long transition period would last
- Whether rollback requires dual-write

**Recommendation:**
- **NO dual-write** - adds complexity without clear benefit
- Write ONLY to test_result.start_time/end_time in new code
- run.start_time/end_time become stale immediately
- Simplifies implementation and testing

## Sources

### Primary (HIGH confidence)

- **MySQL 8.0 Schema (V1.0__reportcard_mysql_ddl.sql)** - Lines 128-150 (run table), Lines 231-252 (test_result table)
  - Confirmed run has start_time/end_time as DATETIME NULL
  - Confirmed test_result has UNIQUE constraint on stage_fk (1:1 relationship)
  - Confirmed test_result currently has: test_result_id, stage_fk, tests, skipped, error, failure, time, test_result_created, external_links, is_success, has_skip, test_suites_json

- **JOOQ Generated Classes** - RunTable.java lines 96-104, TestResultTable.java lines 62-120
  - Confirmed RUN.START_TIME and RUN.END_TIME exist as TableField<RunRecord, Instant>
  - Confirmed TEST_RESULT structure matches schema
  - Verified JOOQ uses Instant type for DATETIME columns

- **StagePathPersistService.java** - Lines 371-390
  - Current updateRunTiming() implementation
  - Null-handling patterns: lines 372-379
  - JOOQ DSL update pattern: lines 381-385

- **JunitController.java** - Lines 233-283, 328-352
  - processKarateTiming() method: lines 328-352
  - Controller data flow: lines 254-261 show stagePathTestResult contains testResultId

- **TestResultModel.java / TestResult.java (DTO)** - TestResult.java lines 21-32
  - Confirmed testResultId field exists in model
  - Verified StagePathTestResult provides access to TestResultModel

- **MySQL 8.0 ALTER TABLE Documentation** - dev.mysql.com/doc/refman/8.0/en/alter-table.html
  - ALTER TABLE ADD COLUMN syntax verified
  - DATETIME NULL column addition confirmed safe
  - AFTER clause for positioning documented

### Secondary (MEDIUM confidence)

- **Grep analysis** - RUN.START_TIME/END_TIME usage
  - Only 2 usages in business logic (StagePathPersistService.java lines 382-383)
  - Generated DAO files have standard accessors (not business logic)
  - Planning docs reference updateRunTiming as expected

- **CLAUDE.md and README_AI.md** - JOOQ workflow documentation
  - Manual MySQL application required (no Flyway)
  - generateJooqSchemaSource task must run after schema changes
  - Test vs production differences documented

### Tertiary (LOW confidence - marked for validation)

None - all findings backed by source code or official documentation.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Direct inspection of build.gradle, JOOQ generated code, and schema files
- Architecture: HIGH - Current implementation examined in detail, patterns extracted from working code
- Pitfalls: HIGH - Common JOOQ workflow issues documented in project README, schema change pitfalls verified

**Research date:** 2026-01-27
**Valid until:** 2026-02-27 (30 days - stable domain, MySQL and JOOQ patterns unlikely to change)

**Technology versions verified:**
- MySQL: 8.0 (schema DDL header, Testcontainers version)
- JOOQ: 3.18.7 (inferred from generated code patterns)
- Java: 17 (CLAUDE.md)
- Gradle: 8.5 (wrapper properties)

**Codebase constraints:**
- No Flyway: Manual schema migration required
- Database-first design: Schema drives JOOQ generation
- Testcontainers: Integration tests use MySQL 8.0.33 container
- 1:1 stage-to-test_result: UNIQUE constraint enforces relationship
