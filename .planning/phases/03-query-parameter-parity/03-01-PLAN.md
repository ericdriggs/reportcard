---
phase: 03-query-parameter-parity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java
  - reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonControllerTest.java
autonomous: true

must_haves:
  truths:
    - "User can call getBranchJobsRuns with ?runs=N and receive limited results"
    - "User can call getJobRunsStages with ?runs=N and receive limited results"
    - "User receives default 60 runs when parameter is omitted"
    - "User receives default 60 runs when parameter is < 1"
    - "Response shape remains unchanged (Map structures preserved)"
  artifacts:
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java"
      provides: "validateRuns() and limitRunsPerJob() helper methods"
      contains: "validateRuns"
    - path: "reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java"
      provides: "Updated endpoints with @RequestParam runs"
      contains: "@RequestParam.*runs"
    - path: "reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonControllerTest.java"
      provides: "Tests for runs parameter behavior"
      contains: "RunsParameter"
  key_links:
    - from: "BrowseJsonController.getBranchJobsRuns"
      to: "validateRuns"
      via: "parameter validation before use"
      pattern: "runs = validateRuns\\(runs\\)"
    - from: "BrowseJsonController.getBranchJobsRuns"
      to: "limitRunsPerJob"
      via: "post-filter cached result"
      pattern: "limitRunsPerJob.*runs"
---

<objective>
Add ?runs=N query parameter to JSON browse endpoints for feature parity with HTML endpoints.

Purpose: Complete feature parity with BrowseUIController - JSON endpoints should support the same filtering as HTML endpoints, allowing clients to limit the number of runs returned per job.

Output: Updated BrowseJsonController with runs parameter on getBranchJobsRuns and getJobRunsStages endpoints, with tests validating parameter handling.
</objective>

<execution_context>
@/Users/eric.r.driggs/.claude/get-shit-done/workflows/execute-plan.md
@/Users/eric.r.driggs/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-query-parameter-parity/03-RESEARCH.md

# Reference files
@reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java
@reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseUIController.java
@reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonControllerTest.java
@reportcard-server/src/main/java/io/github/ericdriggs/reportcard/gen/db/tables/pojos/PojoComparators.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add helper methods and update endpoints</name>
  <files>reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java</files>
  <action>
Add helper methods and update two endpoints in BrowseJsonController:

1. Add validateRuns() method (copy from BrowseUIController lines 175-180):
```java
Integer validateRuns(Integer runs) {
    if (runs == null || runs < 1) {
        return 60;
    }
    return runs;
}
```

2. Add limitRunsPerJob() helper method that post-filters cached results:
```java
private <K> Map<K, Map<JobPojo, Set<RunPojo>>> limitRunsPerJob(
        Map<K, Map<JobPojo, Set<RunPojo>>> input, int maxRuns) {
    Map<K, Map<JobPojo, Set<RunPojo>>> result = new LinkedHashMap<>();
    for (Map.Entry<K, Map<JobPojo, Set<RunPojo>>> outerEntry : input.entrySet()) {
        Map<JobPojo, Set<RunPojo>> limitedJobs = new TreeMap<>(PojoComparators.JOB_CASE_INSENSITIVE_ORDER);
        for (Map.Entry<JobPojo, Set<RunPojo>> jobEntry : outerEntry.getValue().entrySet()) {
            Set<RunPojo> limitedRuns = jobEntry.getValue().stream()
                .sorted(PojoComparators.RUN_DESCENDING)
                .limit(maxRuns)
                .collect(Collectors.toCollection(() ->
                    new TreeSet<>(PojoComparators.RUN_CASE_INSENSITIVE_ORDER)));
            limitedJobs.put(jobEntry.getKey(), limitedRuns);
        }
        result.put(outerEntry.getKey(), limitedJobs);
    }
    return result;
}
```

3. Update getBranchJobsRuns endpoint (lines 57-67):
- Add parameter: `@RequestParam(required = false, defaultValue = "60") Integer runs`
- Call validateRuns(runs) before use
- Apply limitRunsPerJob() to cache result before returning

Updated signature:
```java
public ResponseEntity<Map<BranchPojo, Map<JobPojo, Set<RunPojo>>>> getBranchJobsRuns(
        @PathVariable String company,
        @PathVariable String org,
        @PathVariable String repo,
        @PathVariable String branch,
        @RequestParam(required = false, defaultValue = "60") Integer runs,
        @RequestParam(required = false) Map<String, String> jobInfoFilters) {
    runs = validateRuns(runs);
    Map<BranchPojo, Map<JobPojo, Set<RunPojo>>> fullResult =
        BranchJobsRunsCacheMap.INSTANCE.getValue(new CompanyOrgRepoBranchDTO(company, org, repo, branch));
    return new ResponseEntity<>(limitRunsPerJob(fullResult, runs), HttpStatus.OK);
}
```

4. Update getJobRunsStages endpoint (lines 69-78):
- Add parameter: `@RequestParam(required = false, defaultValue = "60") Integer runs`
- Call validateRuns(runs) before use

This endpoint returns Map<JobPojo, Map<RunPojo, Set<StagePojo>>>, so add a second helper:

```java
private Map<JobPojo, Map<RunPojo, Set<StagePojo>>> limitRunsInJob(
        Map<JobPojo, Map<RunPojo, Set<StagePojo>>> input, int maxRuns) {
    Map<JobPojo, Map<RunPojo, Set<StagePojo>>> result = new TreeMap<>(PojoComparators.JOB_CASE_INSENSITIVE_ORDER);
    for (Map.Entry<JobPojo, Map<RunPojo, Set<StagePojo>>> jobEntry : input.entrySet()) {
        Map<RunPojo, Set<StagePojo>> limitedRuns = jobEntry.getValue().entrySet().stream()
            .sorted(Map.Entry.comparingByKey(PojoComparators.RUN_DESCENDING))
            .limit(maxRuns)
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                Map.Entry::getValue,
                (e1, e2) -> e1,
                () -> new TreeMap<>(PojoComparators.RUN_CASE_INSENSITIVE_ORDER)));
        result.put(jobEntry.getKey(), limitedRuns);
    }
    return result;
}
```

Updated getJobRunsStages signature:
```java
public ResponseEntity<Map<JobPojo, Map<RunPojo, Set<StagePojo>>>> getJobRunsStages(
        @PathVariable String company,
        @PathVariable String org,
        @PathVariable String repo,
        @PathVariable String branch,
        @PathVariable Long jobId,
        @RequestParam(required = false, defaultValue = "60") Integer runs) {
    runs = validateRuns(runs);
    Map<JobPojo, Map<RunPojo, Set<StagePojo>>> fullResult =
        JobRunsStagesCacheMap.INSTANCE.getValue(new CompanyOrgRepoBranchJobDTO(company, org, repo, branch, jobId));
    return new ResponseEntity<>(limitRunsInJob(fullResult, runs), HttpStatus.OK);
}
```

Add required imports:
- java.util.stream.Collectors
- java.util.LinkedHashMap
  </action>
  <verify>
./gradlew :reportcard-server:compileJava --no-daemon
Should compile without errors.
  </verify>
  <done>
- validateRuns() method exists and returns 60 for null/invalid input
- limitRunsPerJob() method exists for branch-level filtering
- limitRunsInJob() method exists for job-level filtering
- getBranchJobsRuns accepts @RequestParam runs with default 60
- getJobRunsStages accepts @RequestParam runs with default 60
- Both endpoints apply validation and filtering
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for runs parameter</name>
  <files>reportcard-server/src/test/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonControllerTest.java</files>
  <action>
Add tests for runs parameter behavior to BrowseJsonControllerTest.

Add a new test section after the error case tests:

```java
// ==================== Runs Parameter Tests ====================

@Test
void getBranchJobsRunsWithRunsParameterTest() {
    // Test with explicit runs parameter (limit to 10)
    ResponseEntity<Map<BranchPojo, Map<JobPojo, Set<RunPojo>>>> response =
        controller.getBranchJobsRuns(TestData.company, TestData.org, TestData.repo,
            TestData.branch, 10, null);

    assertNotNull(response);
    assertEquals(HttpStatus.OK, response.getStatusCode());

    Map<BranchPojo, Map<JobPojo, Set<RunPojo>>> result = response.getBody();
    assertNotNull(result);
    assertFalse(result.isEmpty());

    // Verify runs per job limited to 10
    for (Map<JobPojo, Set<RunPojo>> jobRuns : result.values()) {
        for (Set<RunPojo> runs : jobRuns.values()) {
            assertTrue(runs.size() <= 10, "Each job should have at most 10 runs");
        }
    }
}

@Test
void getBranchJobsRunsDefaultRunsTest() {
    // Test without runs parameter (should use default 60)
    // Note: Updated signature requires runs parameter, pass null to test default behavior
    ResponseEntity<Map<BranchPojo, Map<JobPojo, Set<RunPojo>>>> response =
        controller.getBranchJobsRuns(TestData.company, TestData.org, TestData.repo,
            TestData.branch, null, null);

    assertNotNull(response);
    assertEquals(HttpStatus.OK, response.getStatusCode());

    Map<BranchPojo, Map<JobPojo, Set<RunPojo>>> result = response.getBody();
    assertNotNull(result);
    assertFalse(result.isEmpty());

    // Verify runs per job limited to 60 (default)
    for (Map<JobPojo, Set<RunPojo>> jobRuns : result.values()) {
        for (Set<RunPojo> runs : jobRuns.values()) {
            assertTrue(runs.size() <= 60, "Each job should have at most 60 runs (default)");
        }
    }
}

@Test
void getBranchJobsRunsWithZeroRunsUsesDefaultTest() {
    // Test with runs=0 (should use default 60)
    ResponseEntity<Map<BranchPojo, Map<JobPojo, Set<RunPojo>>>> response =
        controller.getBranchJobsRuns(TestData.company, TestData.org, TestData.repo,
            TestData.branch, 0, null);

    assertNotNull(response);
    assertEquals(HttpStatus.OK, response.getStatusCode());

    // Should return results (not empty due to invalid runs value)
    assertFalse(response.getBody().isEmpty());

    // Verify runs per job limited to 60 (default because 0 < 1)
    for (Map<JobPojo, Set<RunPojo>> jobRuns : response.getBody().values()) {
        for (Set<RunPojo> runs : jobRuns.values()) {
            assertTrue(runs.size() <= 60, "Each job should have at most 60 runs (default for runs=0)");
        }
    }
}

@Test
void getBranchJobsRunsWithNegativeRunsUsesDefaultTest() {
    // Test with runs=-1 (should use default 60)
    ResponseEntity<Map<BranchPojo, Map<JobPojo, Set<RunPojo>>>> response =
        controller.getBranchJobsRuns(TestData.company, TestData.org, TestData.repo,
            TestData.branch, -1, null);

    assertNotNull(response);
    assertEquals(HttpStatus.OK, response.getStatusCode());

    // Should return results (not empty due to invalid runs value)
    assertFalse(response.getBody().isEmpty());
}

@Test
void getJobRunsStagesWithRunsParameterTest() {
    // Test job-level runs parameter
    ResponseEntity<Map<JobPojo, Map<RunPojo, Set<StagePojo>>>> response =
        controller.getJobRunsStages(TestData.company, TestData.org, TestData.repo,
            TestData.branch, TestData.jobId, 5);

    assertNotNull(response);
    assertEquals(HttpStatus.OK, response.getStatusCode());

    Map<JobPojo, Map<RunPojo, Set<StagePojo>>> result = response.getBody();
    assertNotNull(result);
    assertFalse(result.isEmpty());

    // Verify runs limited to 5
    for (Map<RunPojo, Set<StagePojo>> runStages : result.values()) {
        assertTrue(runStages.size() <= 5, "Job should have at most 5 runs");
    }
}

@Test
void getJobRunsStagesDefaultRunsTest() {
    // Test without runs parameter (null should use default 60)
    ResponseEntity<Map<JobPojo, Map<RunPojo, Set<StagePojo>>>> response =
        controller.getJobRunsStages(TestData.company, TestData.org, TestData.repo,
            TestData.branch, TestData.jobId, null);

    assertNotNull(response);
    assertEquals(HttpStatus.OK, response.getStatusCode());

    Map<JobPojo, Map<RunPojo, Set<StagePojo>>> result = response.getBody();
    assertNotNull(result);
    assertFalse(result.isEmpty());

    // Verify runs limited to 60 (default)
    for (Map<RunPojo, Set<StagePojo>> runStages : result.values()) {
        assertTrue(runStages.size() <= 60, "Job should have at most 60 runs (default)");
    }
}
```

Update existing test that calls getBranchJobsRuns (getBranchJobsRunsJsonSuccessTest) to pass the runs parameter:
- Change `controller.getBranchJobsRuns(TestData.company, TestData.org, TestData.repo, TestData.branch, null)`
- To `controller.getBranchJobsRuns(TestData.company, TestData.org, TestData.repo, TestData.branch, null, null)`

The first null is for runs (will use default), second null is for jobInfoFilters.

Similarly update getJobRunsStagesJsonSuccessTest:
- Change `controller.getJobRunsStages(TestData.company, TestData.org, TestData.repo, TestData.branch, TestData.jobId)`
- To `controller.getJobRunsStages(TestData.company, TestData.org, TestData.repo, TestData.branch, TestData.jobId, null)`
  </action>
  <verify>
./gradlew :reportcard-server:test --tests "io.github.ericdriggs.reportcard.controller.browse.BrowseJsonControllerTest" --no-daemon
All tests should pass.
  </verify>
  <done>
- 6 new tests for runs parameter behavior added
- Tests cover: explicit value, null (default), zero value, negative value
- Tests cover both getBranchJobsRuns and getJobRunsStages endpoints
- Existing tests updated to match new method signatures
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify feature parity with HTML controller</name>
  <files>reportcard-server/src/main/java/io/github/ericdriggs/reportcard/controller/browse/BrowseJsonController.java</files>
  <action>
Final verification that JSON endpoint behavior matches HTML endpoint behavior:

1. Verify validateRuns() in BrowseJsonController matches BrowseUIController:
   - Both return 60 when runs < 1
   - Both return runs when runs >= 1

2. Run the full test suite to ensure no regressions:
   ./gradlew :reportcard-server:test --no-daemon

3. Verify the parameter handling is consistent:
   - JSON: @RequestParam(required = false, defaultValue = "60") Integer runs
   - HTML: @RequestParam(required = false, defaultValue = "60") Integer runs
   Both should match.

4. Commit the changes with descriptive message following project conventions.
  </action>
  <verify>
./gradlew :reportcard-server:test --no-daemon
All tests pass including new runs parameter tests.
  </verify>
  <done>
- validateRuns() behavior matches BrowseUIController
- All tests pass
- Feature parity achieved for ?runs=N parameter
- Changes committed
  </done>
</task>

</tasks>

<verification>
1. Both endpoints accept ?runs=N parameter
2. Default value (60) used when parameter omitted or invalid
3. Runs are limited per-job, not globally
4. Response shape unchanged (Map structures preserved)
5. All existing tests still pass
6. New parameter tests pass
</verification>

<success_criteria>
1. `./gradlew :reportcard-server:test` passes with all tests green
2. getBranchJobsRuns accepts ?runs=N and limits results per job
3. getJobRunsStages accepts ?runs=N and limits results
4. validateRuns() returns 60 for null, 0, or negative values
5. Response structures remain Map<K, Map<...>> (no BranchStageViewResponse)
</success_criteria>

<output>
After completion, create `.planning/phases/03-query-parameter-parity/03-01-SUMMARY.md`
</output>
